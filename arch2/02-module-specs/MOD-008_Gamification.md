# MOD-013: æ¸¸æˆåŒ–ä½“éªŒæ¨¡å—

## 1. æ¨¡å—æ¦‚è¿°

### 1.1 æ¨¡å—å®šä½
æ¸¸æˆåŒ–ä½“éªŒæ¨¡å—ä¸ºè®°è´¦åº”ç”¨æ³¨å…¥è¶£å‘³æ€§å’Œå‚ä¸æ„Ÿ,é€šè¿‡"å¤§è°·æ¢ç®—å™¨"å’Œ"æŠ½è¿åŠ¿"åŠŸèƒ½,å°†æ¯ç‡¥çš„æ•°å­—è½¬åŒ–ä¸ºæœ‰è¶£çš„äº’åŠ¨ä½“éªŒ,æå‡ç”¨æˆ·çš„è®°è´¦ç§¯ææ€§å’Œåº”ç”¨ç²˜æ€§ã€‚

### 1.2 ä¸šåŠ¡ä»·å€¼
- **è¶£å‘³åŒ–è®°è´¦**: é€šè¿‡å¤§è°·ç¿”å¹³è–ªèµ„æ¢ç®—,è®©ç”¨æˆ·ä»¥æ›´ç›´è§‚æœ‰è¶£çš„æ–¹å¼ç†è§£æ¶ˆè´¹é‡‘é¢
- **æƒ…æ„Ÿè¿æ¥**: è¿åŠ¿ç³»ç»Ÿä¸ºè®°è´¦è¡Œä¸ºæ·»åŠ ä»ªå¼æ„Ÿ,å¢å¼ºç”¨æˆ·ä¸åº”ç”¨çš„æƒ…æ„Ÿè”ç³»
- **ç”¨æˆ·ç•™å­˜**: æ¸¸æˆåŒ–å…ƒç´ æå‡ç”¨æˆ·æ´»è·ƒåº¦å’Œåº”ç”¨æ‰“å¼€é¢‘ç‡
- **å“ç‰Œå·®å¼‚åŒ–**: ç‹¬ç‰¹çš„æ¸¸æˆåŒ–è®¾è®¡æˆä¸ºäº§å“çš„æ ¸å¿ƒç«äº‰åŠ›

### 1.3 æ ¸å¿ƒåŠŸèƒ½
1. **å¤§è°·æ¢ç®—å™¨**: æ”¯æŒå¤šç§æ¢ç®—å•ä½çš„é‡‘é¢è½¬æ¢å±•ç¤º
2. **è¿åŠ¿ç³»ç»Ÿ**: æ¦‚ç‡åˆ†å¸ƒçš„è¿åŠ¿æŠ½å–æœºåˆ¶
3. **åŠ¨ç”»æ•ˆæœ**: ToaståŠ¨ç”»å’Œè¿åŠ¿å¡ç‰‡ç¿»è½¬æ•ˆæœ
4. **OTAé…ç½®**: æ”¯æŒè¿œç¨‹æ›´æ–°æ¢ç®—å•ä½å’Œè¿åŠ¿å†…å®¹

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 å¤§è°·æ¢ç®—å™¨

#### 2.1.1 æ¢ç®—å•ä½é…ç½®
```
æ”¯æŒçš„æ¢ç®—å•ä½:
- å¤§è°·è–ªèµ„: 2000æ—¥å…ƒ/ç§’
- å‰é‡å®¶ç‰›è‚‰é¥­: 500æ—¥å…ƒ/ç¢—
- æ‰‹æ¸¸åè¿æŠ½: 3000æ—¥å…ƒ/æ¬¡
- æ˜Ÿå·´å…‹æ‹¿é“: 600æ—¥å…ƒ/æ¯
- æ–°å¹²çº¿ä¸œäº¬-å¤§é˜ª: 13,000æ—¥å…ƒ/å•ç¨‹
- iPhone 15 Pro: 159,800æ—¥å…ƒ/å°
```

#### 2.1.2 æ¢ç®—é€»è¾‘
- æ ¹æ®é‡‘é¢å¤§å°è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„æ¢ç®—å•ä½
- æ”¯æŒè‡ªå®šä¹‰æ¢ç®—å•ä½çš„ä¼˜å…ˆçº§
- æ˜¾ç¤ºæ ¼å¼: `ç­‰äºXä¸ª/ä»½/æ¯XXX`

#### 2.1.3 å±•ç¤ºæ–¹å¼
- Toastå½¢å¼: è®°è´¦åè‡ªåŠ¨å¼¹å‡º,3ç§’åè‡ªåŠ¨æ¶ˆå¤±
- æ‰‹åŠ¨è§¦å‘: ç‚¹å‡»äº¤æ˜“è¯¦æƒ…ä¸­çš„æ¢ç®—æŒ‰é’®
- åŠ¨ç”»æ•ˆæœ: ä»åº•éƒ¨æ»‘å…¥,å¸¦æ·¡å…¥æ·¡å‡ºæ•ˆæœ

### 2.2 è¿åŠ¿ç³»ç»Ÿ

#### 2.2.1 è¿åŠ¿ç±»å‹ä¸æ¦‚ç‡
```
è¿åŠ¿åˆ†å¸ƒ:
- å¤§å‰ (10%): "è´¢è¿äº¨é€š,ä»Šæ—¥é€‚åˆæŠ•èµ„ç†è´¢"
- å‰ (30%): "æ”¶æ”¯å¹³è¡¡,ä¿æŒç°çŠ¶å³å¯"
- å°å‰ (35%): "å°æœ‰æ”¶è·,æ§åˆ¶å¼€æ”¯æ›´ä½³"
- å‡¶ (20%): "è´¢è¿æ¬ ä½³,è°¨æ…æ¶ˆè´¹ä¸ºå®œ"
- å¤§å‡¶ (5%): "ç ´è´¢ä¹‹ç›¸,ä»Šæ—¥ä¸å®œå¤§é¢æ”¯å‡º"
```

#### 2.2.2 æŠ½å–è§„åˆ™
- æ¯æ—¥é¦–æ¬¡æ‰“å¼€åº”ç”¨è‡ªåŠ¨è§¦å‘
- æ”¯æŒæ‰‹åŠ¨æŠ½å–(æ¯æ—¥3æ¬¡é™åˆ¶)
- è¿åŠ¿ç»“æœå½“æ—¥æœ‰æ•ˆ

#### 2.2.3 è¿åŠ¿å±•ç¤º
- å¡ç‰‡ç¿»è½¬åŠ¨ç”»
- è¿åŠ¿å›¾æ ‡å’Œé¢œè‰²ä¸»é¢˜
- è¿åŠ¿å»ºè®®æ–‡æ¡ˆ
- åˆ†äº«åŠŸèƒ½

### 2.3 OTAé…ç½®æ”¯æŒ

#### 2.3.1 å¯é…ç½®é¡¹
- æ¢ç®—å•ä½åˆ—è¡¨åŠæ±‡ç‡
- è¿åŠ¿æ–‡æ¡ˆå†…å®¹
- è¿åŠ¿æ¦‚ç‡åˆ†å¸ƒ
- åŠ¨ç”»æ•ˆæœå‚æ•°

#### 2.3.2 é…ç½®æ›´æ–°æœºåˆ¶
- åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥æ›´æ–°
- åå°å®šæ—¶è½®è¯¢
- æœ¬åœ°ç¼“å­˜fallback

## 3. æŠ€æœ¯è®¾è®¡

### 3.1 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Presentation Layer                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  GamificationScreen                                  â”‚
â”‚  â”œâ”€ OhtaniConverterWidget                           â”‚
â”‚  â”‚  â””â”€ OhtaniToast (Animated)                       â”‚
â”‚  â””â”€ FortuneWidget                                    â”‚
â”‚     â”œâ”€ FortuneCard (FlipAnimation)                  â”‚
â”‚     â””â”€ FortuneDialog                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Domain Layer                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  OhtaniConverterUseCase                             â”‚
â”‚  FortuneGeneratorUseCase                            â”‚
â”‚  GetDailyFortuneUseCase                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Data Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ConversionUnitRepositoryImpl                       â”‚
â”‚  FortuneRepositoryImpl                              â”‚
â”‚  OtaConfigService                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æŠ€æœ¯é€‰å‹
- **çŠ¶æ€ç®¡ç†**: Riverpod 2.4+
- **åŠ¨ç”»**: Flutter Animation API + AnimationController
- **æœ¬åœ°å­˜å‚¨**: Drift + SharedPreferences
- **ç½‘ç»œè¯·æ±‚**: dio (OTAé…ç½®)
- **éšæœºæ•°ç”Ÿæˆ**: dart:math Random (åŠ å¯†å®‰å…¨)

## 4. æ•°æ®æ¨¡å‹

### 4.1 é¢†åŸŸæ¨¡å‹

#### 4.1.1 ConversionUnit (æ¢ç®—å•ä½)
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversion_unit.freezed.dart';
part 'conversion_unit.g.dart';

@freezed
class ConversionUnit with _$ConversionUnit {
  const factory ConversionUnit({
    required String id,
    required String name,
    required String unit,
    required double priceInYen,
    required int priority,
    String? iconEmoji,
    String? description,
  }) = _ConversionUnit;

  factory ConversionUnit.fromJson(Map<String, dynamic> json) =>
      _$ConversionUnitFromJson(json);
}
```

#### 4.1.2 Fortune (è¿åŠ¿)
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'fortune.freezed.dart';
part 'fortune.g.dart';

enum FortuneLevel {
  greatBlessing,  // å¤§å‰
  blessing,       // å‰
  smallBlessing,  // å°å‰
  curse,          // å‡¶
  greatCurse,     // å¤§å‡¶
}

@freezed
class Fortune with _$Fortune {
  const factory Fortune({
    required String id,
    required FortuneLevel level,
    required String title,
    required String message,
    required String advice,
    required DateTime date,
    @Default(false) bool isShared,
  }) = _Fortune;

  factory Fortune.fromJson(Map<String, dynamic> json) =>
      _$FortuneFromJson(json);
}
```

#### 4.1.3 ConversionResult (æ¢ç®—ç»“æœ)
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'conversion_unit.dart';

part 'conversion_result.freezed.dart';

@freezed
class ConversionResult with _$ConversionResult {
  const factory ConversionResult({
    required double originalAmount,
    required ConversionUnit unit,
    required double convertedAmount,
    required String displayText,
  }) = _ConversionResult;
}
```

### 4.2 æ•°æ®åº“æ¨¡å‹

#### 4.2.1 Fortunes Table
```dart
import 'package:drift/drift.dart';

class Fortunes extends Table {
  TextColumn get id => text()();
  IntColumn get level => intEnum<FortuneLevel>()();
  TextColumn get title => text()();
  TextColumn get message => text()();
  TextColumn get advice => text()();
  DateTimeColumn get date => dateTime()();
  BoolColumn get isShared => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  @override
  Set<Column> get primaryKey => {id};
}
```

#### 4.2.2 ConversionUnits Table
```dart
import 'package:drift/drift.dart';

class ConversionUnits extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  TextColumn get unit => text()();
  RealColumn get priceInYen => real()();
  IntColumn get priority => integer()();
  TextColumn get iconEmoji => text().nullable()();
  TextColumn get description => text().nullable()();
  BoolColumn get isEnabled => boolean().withDefault(const Constant(true))();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();

  @override
  Set<Column> get primaryKey => {id};
}
```

## 5. æ ¸å¿ƒæµç¨‹

### 5.1 å¤§è°·æ¢ç®—æµç¨‹

```dart
// lib/features/gamification/domain/usecases/convert_to_ohtani.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/conversion_unit.dart';
import '../entities/conversion_result.dart';
import '../repositories/conversion_unit_repository.dart';

part 'convert_to_ohtani.g.dart';

@riverpod
ConvertToOhtaniUseCase convertToOhtaniUseCase(ConvertToOhtaniUseCaseRef ref) {
  final repository = ref.watch(conversionUnitRepositoryProvider);
  return ConvertToOhtaniUseCase(repository);
}

class ConvertToOhtaniUseCase {
  final ConversionUnitRepository _repository;

  ConvertToOhtaniUseCase(this._repository);

  Future<ConversionResult> execute(double amountInYen) async {
    // Get all enabled conversion units sorted by priority
    final units = await _repository.getEnabledUnits();

    if (units.isEmpty) {
      throw Exception('No conversion units available');
    }

    // Select the most appropriate unit based on amount
    final selectedUnit = _selectUnit(amountInYen, units);

    // Calculate converted amount
    final convertedAmount = amountInYen / selectedUnit.priceInYen;

    // Format display text
    final displayText = _formatDisplayText(convertedAmount, selectedUnit);

    return ConversionResult(
      originalAmount: amountInYen,
      unit: selectedUnit,
      convertedAmount: convertedAmount,
      displayText: displayText,
    );
  }

  ConversionUnit _selectUnit(double amount, List<ConversionUnit> units) {
    // Sort by priority
    final sortedUnits = List<ConversionUnit>.from(units)
      ..sort((a, b) => a.priority.compareTo(b.priority));

    // Find the unit where converted amount is in reasonable range (0.1 - 1000)
    for (final unit in sortedUnits) {
      final converted = amount / unit.priceInYen;
      if (converted >= 0.1 && converted <= 1000) {
        return unit;
      }
    }

    // Default to the highest priority unit
    return sortedUnits.first;
  }

  String _formatDisplayText(double amount, ConversionUnit unit) {
    final formattedAmount = amount >= 1
        ? amount.toStringAsFixed(1)
        : amount.toStringAsFixed(2);

    final emoji = unit.iconEmoji ?? '';
    return 'ç­‰äº $formattedAmount ${unit.unit} ${unit.name} $emoji';
  }
}
```

### 5.2 è¿åŠ¿ç”Ÿæˆæµç¨‹

```dart
// lib/features/gamification/domain/usecases/generate_fortune.dart
import 'dart:math';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/fortune.dart';
import '../repositories/fortune_repository.dart';

part 'generate_fortune.g.dart';

@riverpod
GenerateFortuneUseCase generateFortuneUseCase(GenerateFortuneUseCaseRef ref) {
  final repository = ref.watch(fortuneRepositoryProvider);
  return GenerateFortuneUseCase(repository);
}

class GenerateFortuneUseCase {
  final FortuneRepository _repository;
  final Random _random = Random.secure();

  GenerateFortuneUseCase(this._repository);

  Future<Fortune> execute() async {
    // Check daily limit
    final today = DateTime.now();
    final todayCount = await _repository.getFortuneCountByDate(today);

    if (todayCount >= 3) {
      throw Exception('Daily fortune limit reached (3/3)');
    }

    // Generate fortune based on probability distribution
    final level = _generateFortuneLevel();
    final content = await _repository.getFortuneContent(level);

    final fortune = Fortune(
      id: _generateId(),
      level: level,
      title: content.title,
      message: content.message,
      advice: content.advice,
      date: today,
      isShared: false,
    );

    // Save to database
    await _repository.saveFortune(fortune);

    return fortune;
  }

  FortuneLevel _generateFortuneLevel() {
    final value = _random.nextDouble() * 100;

    // Probability distribution:
    // Great Blessing: 10% (0-10)
    // Blessing: 30% (10-40)
    // Small Blessing: 35% (40-75)
    // Curse: 20% (75-95)
    // Great Curse: 5% (95-100)

    if (value < 10) {
      return FortuneLevel.greatBlessing;
    } else if (value < 40) {
      return FortuneLevel.blessing;
    } else if (value < 75) {
      return FortuneLevel.smallBlessing;
    } else if (value < 95) {
      return FortuneLevel.curse;
    } else {
      return FortuneLevel.greatCurse;
    }
  }

  String _generateId() {
    return 'fortune_${DateTime.now().millisecondsSinceEpoch}_${_random.nextInt(9999)}';
  }
}
```

### 5.3 è·å–æ¯æ—¥è¿åŠ¿æµç¨‹

```dart
// lib/features/gamification/domain/usecases/get_daily_fortune.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/fortune.dart';
import '../repositories/fortune_repository.dart';

part 'get_daily_fortune.g.dart';

@riverpod
GetDailyFortuneUseCase getDailyFortuneUseCase(GetDailyFortuneUseCaseRef ref) {
  final repository = ref.watch(fortuneRepositoryProvider);
  return GetDailyFortuneUseCase(repository);
}

class GetDailyFortuneUseCase {
  final FortuneRepository _repository;

  GetDailyFortuneUseCase(this._repository);

  Future<Fortune?> execute() async {
    final today = DateTime.now();
    final fortunes = await _repository.getFortunesByDate(today);

    if (fortunes.isEmpty) {
      return null;
    }

    // Return the latest fortune of the day
    return fortunes.first;
  }

  Future<int> getRemainingCount() async {
    final today = DateTime.now();
    final count = await _repository.getFortuneCountByDate(today);
    return 3 - count;
  }
}
```

## 6. Repositoryå®ç°

### 6.1 ConversionUnitRepository

```dart
// lib/features/gamification/data/repositories/conversion_unit_repository_impl.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/conversion_unit.dart';
import '../../domain/repositories/conversion_unit_repository.dart';
import '../../../../core/database/app_database.dart';

part 'conversion_unit_repository_impl.g.dart';

@riverpod
ConversionUnitRepository conversionUnitRepository(
  ConversionUnitRepositoryRef ref,
) {
  final database = ref.watch(appDatabaseProvider);
  return ConversionUnitRepositoryImpl(database);
}

class ConversionUnitRepositoryImpl implements ConversionUnitRepository {
  final AppDatabase _database;

  ConversionUnitRepositoryImpl(this._database);

  @override
  Future<List<ConversionUnit>> getEnabledUnits() async {
    final units = await (_database.select(_database.conversionUnits)
          ..where((tbl) => tbl.isEnabled.equals(true))
          ..orderBy([
            (tbl) => OrderingTerm(expression: tbl.priority),
          ]))
        .get();

    return units.map(_toEntity).toList();
  }

  @override
  Future<void> updateUnit(ConversionUnit unit) async {
    await _database.into(_database.conversionUnits).insert(
          ConversionUnitsCompanion.insert(
            id: unit.id,
            name: unit.name,
            unit: unit.unit,
            priceInYen: unit.priceInYen,
            priority: unit.priority,
            iconEmoji: Value(unit.iconEmoji),
            description: Value(unit.description),
          ),
          mode: InsertMode.insertOrReplace,
        );
  }

  @override
  Future<void> syncFromOta(List<ConversionUnit> units) async {
    await _database.transaction(() async {
      for (final unit in units) {
        await updateUnit(unit);
      }
    });
  }

  @override
  Future<void> initializeDefaults() async {
    final existingCount = await (_database.select(_database.conversionUnits).get())
        .then((rows) => rows.length);

    if (existingCount > 0) {
      return; // Already initialized
    }

    final defaultUnits = [
      ConversionUnit(
        id: 'ohtani_salary',
        name: 'å¤§è°·è–ªèµ„',
        unit: 'ç§’',
        priceInYen: 2000,
        priority: 1,
        iconEmoji: 'âš¾',
        description: 'å¤§è°·ç¿”å¹³æ¯ç§’æ”¶å…¥çº¦2000æ—¥å…ƒ',
      ),
      ConversionUnit(
        id: 'yoshinoya',
        name: 'å‰é‡å®¶ç‰›è‚‰é¥­',
        unit: 'ç¢—',
        priceInYen: 500,
        priority: 2,
        iconEmoji: 'ğŸœ',
        description: 'ä¸€ç¢—å‰é‡å®¶ç‰›è‚‰é¥­çº¦500æ—¥å…ƒ',
      ),
      ConversionUnit(
        id: 'gacha',
        name: 'æ‰‹æ¸¸åè¿æŠ½',
        unit: 'æ¬¡',
        priceInYen: 3000,
        priority: 3,
        iconEmoji: 'ğŸ°',
        description: 'æ‰‹æ¸¸åè¿æŠ½çº¦3000æ—¥å…ƒ',
      ),
      ConversionUnit(
        id: 'starbucks',
        name: 'æ˜Ÿå·´å…‹æ‹¿é“',
        unit: 'æ¯',
        priceInYen: 600,
        priority: 4,
        iconEmoji: 'â˜•',
        description: 'ä¸€æ¯æ˜Ÿå·´å…‹æ‹¿é“çº¦600æ—¥å…ƒ',
      ),
      ConversionUnit(
        id: 'shinkansen',
        name: 'æ–°å¹²çº¿ä¸œäº¬-å¤§é˜ª',
        unit: 'å•ç¨‹',
        priceInYen: 13000,
        priority: 5,
        iconEmoji: 'ğŸš„',
        description: 'æ–°å¹²çº¿ä¸œäº¬-å¤§é˜ªå•ç¨‹çº¦13,000æ—¥å…ƒ',
      ),
      ConversionUnit(
        id: 'iphone15pro',
        name: 'iPhone 15 Pro',
        unit: 'å°',
        priceInYen: 159800,
        priority: 6,
        iconEmoji: 'ğŸ“±',
        description: 'iPhone 15 Proçº¦159,800æ—¥å…ƒ',
      ),
    ];

    for (final unit in defaultUnits) {
      await updateUnit(unit);
    }
  }

  ConversionUnit _toEntity(ConversionUnitData data) {
    return ConversionUnit(
      id: data.id,
      name: data.name,
      unit: data.unit,
      priceInYen: data.priceInYen,
      priority: data.priority,
      iconEmoji: data.iconEmoji,
      description: data.description,
    );
  }
}
```

### 6.2 FortuneRepository

```dart
// lib/features/gamification/data/repositories/fortune_repository_impl.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/fortune.dart';
import '../../domain/repositories/fortune_repository.dart';
import '../../../../core/database/app_database.dart';

part 'fortune_repository_impl.g.dart';

@riverpod
FortuneRepository fortuneRepository(FortuneRepositoryRef ref) {
  final database = ref.watch(appDatabaseProvider);
  return FortuneRepositoryImpl(database);
}

class FortuneRepositoryImpl implements FortuneRepository {
  final AppDatabase _database;

  FortuneRepositoryImpl(this._database);

  @override
  Future<void> saveFortune(Fortune fortune) async {
    await _database.into(_database.fortunes).insert(
          FortunesCompanion.insert(
            id: fortune.id,
            level: fortune.level,
            title: fortune.title,
            message: fortune.message,
            advice: fortune.advice,
            date: fortune.date,
            isShared: Value(fortune.isShared),
          ),
        );
  }

  @override
  Future<List<Fortune>> getFortunesByDate(DateTime date) async {
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = DateTime(date.year, date.month, date.day, 23, 59, 59);

    final fortunes = await (_database.select(_database.fortunes)
          ..where((tbl) => tbl.date.isBiggerOrEqualValue(startOfDay))
          ..where((tbl) => tbl.date.isSmallerOrEqualValue(endOfDay))
          ..orderBy([
            (tbl) => OrderingTerm(expression: tbl.createdAt, mode: OrderingMode.desc),
          ]))
        .get();

    return fortunes.map(_toEntity).toList();
  }

  @override
  Future<int> getFortuneCountByDate(DateTime date) async {
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = DateTime(date.year, date.month, date.day, 23, 59, 59);

    final count = await (_database.select(_database.fortunes)
          ..where((tbl) => tbl.date.isBiggerOrEqualValue(startOfDay))
          ..where((tbl) => tbl.date.isSmallerOrEqualValue(endOfDay)))
        .get()
        .then((rows) => rows.length);

    return count;
  }

  @override
  Future<FortuneContent> getFortuneContent(FortuneLevel level) async {
    // In a real implementation, this would fetch from database or OTA config
    // For now, return hardcoded content
    return _getDefaultFortuneContent(level);
  }

  FortuneContent _getDefaultFortuneContent(FortuneLevel level) {
    switch (level) {
      case FortuneLevel.greatBlessing:
        return FortuneContent(
          title: 'å¤§å‰',
          message: 'è´¢è¿äº¨é€š,ä»Šæ—¥é€‚åˆæŠ•èµ„ç†è´¢',
          advice: 'æŠŠæ¡æœºä¼š,é€‚åº¦è¿›å–',
        );
      case FortuneLevel.blessing:
        return FortuneContent(
          title: 'å‰',
          message: 'æ”¶æ”¯å¹³è¡¡,ä¿æŒç°çŠ¶å³å¯',
          advice: 'ç¨³ä¸­æ±‚è¿›,ç§¯å°‘æˆå¤š',
        );
      case FortuneLevel.smallBlessing:
        return FortuneContent(
          title: 'å°å‰',
          message: 'å°æœ‰æ”¶è·,æ§åˆ¶å¼€æ”¯æ›´ä½³',
          advice: 'é‡å…¥ä¸ºå‡º,æœªé›¨ç»¸ç¼ª',
        );
      case FortuneLevel.curse:
        return FortuneContent(
          title: 'å‡¶',
          message: 'è´¢è¿æ¬ ä½³,è°¨æ…æ¶ˆè´¹ä¸ºå®œ',
          advice: 'å‡å°‘æ”¯å‡º,å¼€æºèŠ‚æµ',
        );
      case FortuneLevel.greatCurse:
        return FortuneContent(
          title: 'å¤§å‡¶',
          message: 'ç ´è´¢ä¹‹ç›¸,ä»Šæ—¥ä¸å®œå¤§é¢æ”¯å‡º',
          advice: 'é¿å…å†²åŠ¨æ¶ˆè´¹,å®ˆä½é’±åŒ…',
        );
    }
  }

  Fortune _toEntity(FortuneData data) {
    return Fortune(
      id: data.id,
      level: data.level,
      title: data.title,
      message: data.message,
      advice: data.advice,
      date: data.date,
      isShared: data.isShared,
    );
  }
}

class FortuneContent {
  final String title;
  final String message;
  final String advice;

  FortuneContent({
    required this.title,
    required this.message,
    required this.advice,
  });
}
```

## 7. UIç»„ä»¶è®¾è®¡

### 7.1 OhtaniToast (æ¢ç®—Toast)

```dart
// lib/features/gamification/presentation/widgets/ohtani_toast.dart
import 'package:flutter/material.dart';
import '../../domain/entities/conversion_result.dart';

class OhtaniToast extends StatefulWidget {
  final ConversionResult result;
  final VoidCallback? onDismiss;

  const OhtaniToast({
    Key? key,
    required this.result,
    this.onDismiss,
  }) : super(key: key);

  @override
  State<OhtaniToast> createState() => _OhtaniToastState();

  static void show(BuildContext context, ConversionResult result) {
    final overlay = Overlay.of(context);
    late OverlayEntry overlayEntry;

    overlayEntry = OverlayEntry(
      builder: (context) => OhtaniToast(
        result: result,
        onDismiss: () => overlayEntry.remove(),
      ),
    );

    overlay.insert(overlayEntry);

    // Auto dismiss after 3 seconds
    Future.delayed(const Duration(seconds: 3), () {
      overlayEntry.remove();
    });
  }
}

class _OhtaniToastState extends State<OhtaniToast>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Offset> _slideAnimation;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );

    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, 1),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOutCubic,
    ));

    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeIn,
    ));

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _dismiss() async {
    await _controller.reverse();
    widget.onDismiss?.call();
  }

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: 16,
      right: 16,
      bottom: 100,
      child: SlideTransition(
        position: _slideAnimation,
        child: FadeTransition(
          opacity: _fadeAnimation,
          child: Material(
            color: Colors.transparent,
            child: Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primaryContainer,
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Text(
                    widget.result.unit.iconEmoji ?? 'ğŸ’°',
                    style: const TextStyle(fontSize: 32),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          'Â¥${widget.result.originalAmount.toStringAsFixed(0)}',
                          style: Theme.of(context).textTheme.titleMedium,
                        ),
                        const SizedBox(height: 4),
                        Text(
                          widget.result.displayText,
                          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                                color: Theme.of(context).colorScheme.onPrimaryContainer,
                              ),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: _dismiss,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

### 7.2 FortuneCard (è¿åŠ¿å¡ç‰‡)

```dart
// lib/features/gamification/presentation/widgets/fortune_card.dart
import 'package:flutter/material.dart';
import 'dart:math' as math;
import '../../domain/entities/fortune.dart';

class FortuneCard extends StatefulWidget {
  final Fortune? fortune;
  final VoidCallback onTap;
  final bool isFlipping;

  const FortuneCard({
    Key? key,
    this.fortune,
    required this.onTap,
    this.isFlipping = false,
  }) : super(key: key);

  @override
  State<FortuneCard> createState() => _FortuneCardState();
}

class _FortuneCardState extends State<FortuneCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _flipAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );

    _flipAnimation = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(FortuneCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isFlipping && !oldWidget.isFlipping) {
      _controller.forward(from: 0);
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.fortune == null ? widget.onTap : null,
      child: AnimatedBuilder(
        animation: _flipAnimation,
        builder: (context, child) {
          final angle = _flipAnimation.value * math.pi;
          final transform = Matrix4.identity()
            ..setEntry(3, 2, 0.001)
            ..rotateY(angle);

          final showBack = angle > math.pi / 2;

          return Transform(
            transform: transform,
            alignment: Alignment.center,
            child: showBack
                ? _buildFortuneFace()
                : _buildCardBack(),
          );
        },
      ),
    );
  }

  Widget _buildCardBack() {
    return Container(
      width: 280,
      height: 400,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Colors.red.shade700,
            Colors.red.shade900,
          ],
        ),
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 20,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text(
              'ä»Šæ—¥è¿åŠ¿',
              style: TextStyle(
                color: Colors.white,
                fontSize: 32,
                fontWeight: FontWeight.bold,
                letterSpacing: 8,
              ),
            ),
            const SizedBox(height: 20),
            Text(
              'ç‚¹å‡»æŠ½å–',
              style: TextStyle(
                color: Colors.white.withOpacity(0.8),
                fontSize: 16,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFortuneFace() {
    if (widget.fortune == null) {
      return _buildCardBack();
    }

    final fortune = widget.fortune!;
    final colors = _getFortuneColors(fortune.level);

    return Transform(
      transform: Matrix4.identity()..rotateY(math.pi),
      alignment: Alignment.center,
      child: Container(
        width: 280,
        height: 400,
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: colors,
          ),
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.2),
              blurRadius: 20,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                _getFortuneIcon(fortune.level),
                style: const TextStyle(fontSize: 64),
              ),
              const SizedBox(height: 20),
              Text(
                fortune.title,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 48,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 20),
              Text(
                fortune.message,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                ),
              ),
              const SizedBox(height: 20),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  fortune.advice,
                  textAlign: TextAlign.center,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  List<Color> _getFortuneColors(FortuneLevel level) {
    switch (level) {
      case FortuneLevel.greatBlessing:
        return [Colors.amber.shade600, Colors.orange.shade800];
      case FortuneLevel.blessing:
        return [Colors.green.shade600, Colors.teal.shade800];
      case FortuneLevel.smallBlessing:
        return [Colors.blue.shade600, Colors.indigo.shade800];
      case FortuneLevel.curse:
        return [Colors.grey.shade600, Colors.blueGrey.shade800];
      case FortuneLevel.greatCurse:
        return [Colors.deepPurple.shade700, Colors.deepPurple.shade900];
    }
  }

  String _getFortuneIcon(FortuneLevel level) {
    switch (level) {
      case FortuneLevel.greatBlessing:
        return 'ğŸ‰';
      case FortuneLevel.blessing:
        return 'âœ¨';
      case FortuneLevel.smallBlessing:
        return 'ğŸŒŸ';
      case FortuneLevel.curse:
        return 'â˜ï¸';
      case FortuneLevel.greatCurse:
        return 'âš¡';
    }
  }
}
```

### 7.3 GamificationScreen (æ¸¸æˆåŒ–ä¸»é¡µé¢)

```dart
// lib/features/gamification/presentation/screens/gamification_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/usecases/generate_fortune.dart';
import '../../domain/usecases/get_daily_fortune.dart';
import '../widgets/fortune_card.dart';
import '../widgets/ohtani_toast.dart';

class GamificationScreen extends ConsumerStatefulWidget {
  const GamificationScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<GamificationScreen> createState() => _GamificationScreenState();
}

class _GamificationScreenState extends ConsumerState<GamificationScreen> {
  bool _isFlipping = false;

  @override
  Widget build(BuildContext context) {
    final dailyFortuneAsync = ref.watch(getDailyFortuneUseCaseProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('æ¸¸æˆåŒ–ä½“éªŒ'),
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            onPressed: _showFortuneHistory,
          ),
        ],
      ),
      body: dailyFortuneAsync.when(
        data: (getDailyFortune) {
          return FutureBuilder(
            future: getDailyFortune.execute(),
            builder: (context, snapshot) {
              final fortune = snapshot.data;

              return FutureBuilder<int>(
                future: getDailyFortune.getRemainingCount(),
                builder: (context, countSnapshot) {
                  final remainingCount = countSnapshot.data ?? 3;

                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        FortuneCard(
                          fortune: fortune,
                          onTap: () => _drawFortune(),
                          isFlipping: _isFlipping,
                        ),
                        const SizedBox(height: 40),
                        Text(
                          'ä»Šæ—¥å‰©ä½™æ¬¡æ•°: $remainingCount/3',
                          style: Theme.of(context).textTheme.bodyLarge,
                        ),
                        const SizedBox(height: 20),
                        if (fortune != null && !fortune.isShared)
                          ElevatedButton.icon(
                            onPressed: () => _shareFortune(fortune),
                            icon: const Icon(Icons.share),
                            label: const Text('åˆ†äº«è¿åŠ¿'),
                          ),
                      ],
                    ),
                  );
                },
              );
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Text('åŠ è½½å¤±è´¥: $error'),
        ),
      ),
    );
  }

  Future<void> _drawFortune() async {
    if (_isFlipping) return;

    setState(() {
      _isFlipping = true;
    });

    try {
      final generateFortune = await ref.read(generateFortuneUseCaseProvider.future);
      final fortune = await generateFortune.execute();

      // Wait for flip animation
      await Future.delayed(const Duration(milliseconds: 600));

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('æŠ½åˆ°äº†${fortune.title}!'),
            backgroundColor: _getFortuneColor(fortune.level),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString()),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      setState(() {
        _isFlipping = false;
      });
    }
  }

  Color _getFortuneColor(FortuneLevel level) {
    switch (level) {
      case FortuneLevel.greatBlessing:
        return Colors.orange;
      case FortuneLevel.blessing:
        return Colors.green;
      case FortuneLevel.smallBlessing:
        return Colors.blue;
      case FortuneLevel.curse:
        return Colors.grey;
      case FortuneLevel.greatCurse:
        return Colors.deepPurple;
    }
  }

  void _shareFortune(Fortune fortune) {
    // TODO: Implement share functionality
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('åˆ†äº«åŠŸèƒ½å¼€å‘ä¸­...')),
    );
  }

  void _showFortuneHistory() {
    // TODO: Navigate to fortune history screen
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('å†å²è®°å½•åŠŸèƒ½å¼€å‘ä¸­...')),
    );
  }
}
```

## 8. æµ‹è¯•ç­–ç•¥

### 8.1 Unit Tests

```dart
// test/features/gamification/domain/usecases/convert_to_ohtani_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

@GenerateMocks([ConversionUnitRepository])
void main() {
  late ConvertToOhtaniUseCase useCase;
  late MockConversionUnitRepository mockRepository;

  setUp(() {
    mockRepository = MockConversionUnitRepository();
    useCase = ConvertToOhtaniUseCase(mockRepository);
  });

  group('ConvertToOhtaniUseCase', () {
    final testUnits = [
      ConversionUnit(
        id: 'yoshinoya',
        name: 'å‰é‡å®¶ç‰›è‚‰é¥­',
        unit: 'ç¢—',
        priceInYen: 500,
        priority: 1,
        iconEmoji: 'ğŸœ',
      ),
      ConversionUnit(
        id: 'gacha',
        name: 'æ‰‹æ¸¸åè¿æŠ½',
        unit: 'æ¬¡',
        priceInYen: 3000,
        priority: 2,
        iconEmoji: 'ğŸ°',
      ),
    ];

    test('should select appropriate unit based on amount', () async {
      // Arrange
      when(mockRepository.getEnabledUnits())
          .thenAnswer((_) async => testUnits);

      // Act
      final result = await useCase.execute(1500);

      // Assert
      expect(result.unit.id, 'yoshinoya'); // 1500/500 = 3 bowls (reasonable)
      expect(result.convertedAmount, 3.0);
      expect(result.displayText, contains('å‰é‡å®¶ç‰›è‚‰é¥­'));
    });

    test('should format display text correctly', () async {
      // Arrange
      when(mockRepository.getEnabledUnits())
          .thenAnswer((_) async => testUnits);

      // Act
      final result = await useCase.execute(500);

      // Assert
      expect(result.displayText, 'ç­‰äº 1.0 ç¢— å‰é‡å®¶ç‰›è‚‰é¥­ ğŸœ');
    });

    test('should throw exception when no units available', () async {
      // Arrange
      when(mockRepository.getEnabledUnits())
          .thenAnswer((_) async => []);

      // Act & Assert
      expect(
        () => useCase.execute(1000),
        throwsA(isA<Exception>()),
      );
    });
  });
}
```

### 8.2 Widget Tests

```dart
// test/features/gamification/presentation/widgets/fortune_card_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('FortuneCard', () {
    testWidgets('should show card back when no fortune', (tester) async {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FortuneCard(
              fortune: null,
              onTap: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('ä»Šæ—¥è¿åŠ¿'), findsOneWidget);
      expect(find.text('ç‚¹å‡»æŠ½å–'), findsOneWidget);
    });

    testWidgets('should show fortune when available', (tester) async {
      // Arrange
      final fortune = Fortune(
        id: 'test',
        level: FortuneLevel.greatBlessing,
        title: 'å¤§å‰',
        message: 'è´¢è¿äº¨é€š',
        advice: 'æŠŠæ¡æœºä¼š',
        date: DateTime.now(),
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FortuneCard(
              fortune: fortune,
              onTap: () {},
              isFlipping: true,
            ),
          ),
        ),
      );

      // Wait for flip animation
      await tester.pumpAndSettle();

      // Assert
      expect(find.text('å¤§å‰'), findsOneWidget);
      expect(find.text('è´¢è¿äº¨é€š'), findsOneWidget);
    });

    testWidgets('should trigger onTap when card is tapped', (tester) async {
      // Arrange
      var tapped = false;
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FortuneCard(
              fortune: null,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      // Act
      await tester.tap(find.byType(FortuneCard));
      await tester.pump();

      // Assert
      expect(tapped, true);
    });
  });
}
```

### 8.3 Integration Tests

```dart
// test/features/gamification/domain/usecases/generate_fortune_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

@GenerateMocks([FortuneRepository])
void main() {
  late GenerateFortuneUseCase useCase;
  late MockFortuneRepository mockRepository;

  setUp(() {
    mockRepository = MockFortuneRepository();
    useCase = GenerateFortuneUseCase(mockRepository);
  });

  group('GenerateFortuneUseCase', () {
    test('should generate fortune when under daily limit', () async {
      // Arrange
      when(mockRepository.getFortuneCountByDate(any))
          .thenAnswer((_) async => 2);
      when(mockRepository.getFortuneContent(any))
          .thenAnswer((_) async => FortuneContent(
                title: 'å¤§å‰',
                message: 'è´¢è¿äº¨é€š',
                advice: 'æŠŠæ¡æœºä¼š',
              ));
      when(mockRepository.saveFortune(any))
          .thenAnswer((_) async => {});

      // Act
      final fortune = await useCase.execute();

      // Assert
      expect(fortune.title, isNotEmpty);
      expect(fortune.message, isNotEmpty);
      expect(fortune.advice, isNotEmpty);
      verify(mockRepository.saveFortune(any)).called(1);
    });

    test('should throw exception when daily limit reached', () async {
      // Arrange
      when(mockRepository.getFortuneCountByDate(any))
          .thenAnswer((_) async => 3);

      // Act & Assert
      expect(
        () => useCase.execute(),
        throwsA(isA<Exception>()),
      );
      verifyNever(mockRepository.saveFortune(any));
    });

    test('should follow probability distribution', () async {
      // Arrange
      when(mockRepository.getFortuneCountByDate(any))
          .thenAnswer((_) async => 0);
      when(mockRepository.getFortuneContent(any))
          .thenAnswer((_) async => FortuneContent(
                title: 'Test',
                message: 'Test',
                advice: 'Test',
              ));
      when(mockRepository.saveFortune(any))
          .thenAnswer((_) async => {});

      // Act - Generate 1000 fortunes to test distribution
      final levels = <FortuneLevel>[];
      for (var i = 0; i < 1000; i++) {
        final fortune = await useCase.execute();
        levels.add(fortune.level);
      }

      // Assert - Check approximate distribution
      final greatBlessingCount = levels.where((l) => l == FortuneLevel.greatBlessing).length;
      final blessingCount = levels.where((l) => l == FortuneLevel.blessing).length;
      final smallBlessingCount = levels.where((l) => l == FortuneLevel.smallBlessing).length;
      final curseCount = levels.where((l) => l == FortuneLevel.curse).length;
      final greatCurseCount = levels.where((l) => l == FortuneLevel.greatCurse).length;

      // Allow 5% deviation from expected probabilities
      expect(greatBlessingCount / 1000, closeTo(0.10, 0.05)); // ~10%
      expect(blessingCount / 1000, closeTo(0.30, 0.05)); // ~30%
      expect(smallBlessingCount / 1000, closeTo(0.35, 0.05)); // ~35%
      expect(curseCount / 1000, closeTo(0.20, 0.05)); // ~20%
      expect(greatCurseCount / 1000, closeTo(0.05, 0.05)); // ~5%
    });
  });
}
```

## 9. æ€§èƒ½ä¼˜åŒ–

### 9.1 æ•°æ®åº“ç´¢å¼•
```sql
CREATE INDEX idx_fortunes_date ON fortunes(date);
CREATE INDEX idx_conversion_units_priority ON conversion_units(priority);
CREATE INDEX idx_conversion_units_enabled ON conversion_units(is_enabled);
```

### 9.2 ç¼“å­˜ç­–ç•¥
- æ¢ç®—å•ä½åˆ—è¡¨ç¼“å­˜30åˆ†é’Ÿ
- OTAé…ç½®ç¼“å­˜24å°æ—¶
- è¿åŠ¿è®°å½•å†…å­˜ç¼“å­˜å½“æ—¥æ•°æ®

### 9.3 åŠ¨ç”»ä¼˜åŒ–
- ä½¿ç”¨`RepaintBoundary`åŒ…è£¹åŠ¨ç”»ç»„ä»¶
- é¿å…ä¸å¿…è¦çš„é‡å»º
- ä½¿ç”¨`const`æ„é€ å‡½æ•°

### 9.4 ç½‘ç»œä¼˜åŒ–
- OTAé…ç½®å¢é‡æ›´æ–°
- æœ¬åœ°fallbackæœºåˆ¶
- è¯·æ±‚å¤±è´¥é‡è¯•ç­–ç•¥

## 10. æ€»ç»“

æ¸¸æˆåŒ–ä½“éªŒæ¨¡å—é€šè¿‡å¤§è°·æ¢ç®—å™¨å’Œè¿åŠ¿ç³»ç»Ÿ,ä¸ºè®°è´¦åº”ç”¨æ³¨å…¥äº†è¶£å‘³æ€§å’Œå‚ä¸æ„Ÿã€‚æ ¸å¿ƒæŠ€æœ¯å®ç°åŒ…æ‹¬:

1. **æ¢ç®—ç³»ç»Ÿ**: åŸºäºé‡‘é¢èŒƒå›´è‡ªåŠ¨é€‰æ‹©åˆé€‚å•ä½,æ”¯æŒOTAé…ç½®æ›´æ–°
2. **è¿åŠ¿ç³»ç»Ÿ**: æ¦‚ç‡åˆ†å¸ƒçš„è¿åŠ¿ç”Ÿæˆ,æ¯æ—¥é™åˆ¶æœºåˆ¶
3. **åŠ¨ç”»æ•ˆæœ**: æµç•…çš„Toastæ»‘å…¥ã€å¡ç‰‡ç¿»è½¬åŠ¨ç”»
4. **æ•°æ®æŒä¹…åŒ–**: Driftæ•°æ®åº“å­˜å‚¨è¿åŠ¿è®°å½•å’Œæ¢ç®—å•ä½
5. **çŠ¶æ€ç®¡ç†**: Riverpodå®ç°å“åº”å¼çŠ¶æ€æ›´æ–°

è¯¥æ¨¡å—éµå¾ªClean Architectureè®¾è®¡,ä¿æŒäº†è‰¯å¥½çš„å¯æµ‹è¯•æ€§å’Œå¯ç»´æŠ¤æ€§,ä¸ºåç»­åŠŸèƒ½æ‰©å±•(å¦‚æ›´å¤šæ¢ç®—å•ä½ã€è¿åŠ¿åˆ†äº«ç¤¾äº¤åŠŸèƒ½ç­‰)æä¾›äº†åšå®åŸºç¡€ã€‚
