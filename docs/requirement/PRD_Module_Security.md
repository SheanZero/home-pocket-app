# PRD - å®‰å…¨ä¸éšç§æ¨¡å—

**æ¨¡å—ID:** MOD-006
**æ¨¡å—åç§°:** å®‰å…¨ä¸éšç§æ¨¡å—
**ç‰ˆæœ¬:** 1.0
**åˆ›å»ºæ—¥æœŸ:** 2026å¹´2æœˆ3æ—¥
**ä¼˜å…ˆçº§:** P0ï¼ˆMVPå¿…å¤‡ï¼‰
**é¢„ä¼°å·¥æ—¶:** 10å¤©

---

## 1. æ¨¡å—æ¦‚è¿°

### 1.1 åŠŸèƒ½å®šä¹‰

å®‰å…¨ä¸éšç§æ¨¡å—æ˜¯Home Pocketçš„æ ¸å¿ƒç«äº‰åŠ›,å®ç°å®Œæ•´çš„ç«¯åˆ°ç«¯åŠ å¯†ï¼ˆE2EEï¼‰å’Œé˜²ç¯¡æ”¹æœºåˆ¶ã€‚åŒ…æ‹¬:

- **å¯†é’¥ç®¡ç†ï¼ˆE02ï¼‰:** è®¾å¤‡å¯†é’¥å¯¹ç”Ÿæˆã€Recovery Kitå¤‡ä»½ã€å¯†é’¥æ¢å¤
- **ç”Ÿç‰©è¯†åˆ«é”ï¼ˆE03ï¼‰:** Face ID/Touch ID/æŒ‡çº¹è¯†åˆ«å¯åŠ¨è®¤è¯
- **å“ˆå¸Œé“¾å®¡è®¡ï¼ˆD03ï¼‰:** åŒºå—é“¾å¼é˜²ç¯¡æ”¹è®°å½•,å¯å¯¼å‡ºå®¡è®¡æŠ¥å‘Š
- **éšç§å®£è¨€å¼•å¯¼ï¼ˆE01ï¼‰:** é¦–æ¬¡å¯åŠ¨ä¸‰é¡µéšç§æ‰¿è¯ºå±•ç¤º
- **æ•°æ®åŠ å¯†:** SQLCipheræ•°æ®åº“åŠ å¯†ã€å¤‡æ³¨å­—æ®µåŠ å¯†ã€ç…§ç‰‡åŠ å¯†

**æ ¸å¿ƒä»·å€¼ä¸»å¼ :**
åœ¨éšç§æ³„éœ²é¢‘å‘çš„æ—¶ä»£,Home Pocketæ‰¿è¯º"ä½ çš„æ•°æ®åªå±äºä½ "ã€‚é€šè¿‡å¼€æºä»£ç ã€E2EEæ¶æ„ã€å“ˆå¸Œé“¾å®¡è®¡,å»ºç«‹ç”¨æˆ·ä¿¡ä»»ã€‚

### 1.2 ç”¨æˆ·åœºæ™¯ä¸ç—›ç‚¹

**ç”¨æˆ·ç”»åƒ:**
- ä½è—¤å¤ªéƒï¼ˆ38å²,ITå·¥ç¨‹å¸ˆï¼‰,éšç§æ„è¯†å¼º
- æ‹…å¿ƒä¼ ç»Ÿè®°è´¦åº”ç”¨å°†æ•°æ®ä¸Šä¼ æœåŠ¡å™¨
- æ›¾ç»å†æŸé‡‘èåº”ç”¨æ•°æ®æ³„éœ²äº‹ä»¶,è´¦å•æ˜ç»†è¢«æ›å…‰

**ç—›ç‚¹:**
1. **éšç§ç„¦è™‘:** "æˆ‘çš„æ”¶å…¥ã€æ¶ˆè´¹ä¹ æƒ¯ä¼šè¢«å…¬å¸çœ‹åˆ°å—?"
2. **æ•°æ®æ³„éœ²é£é™©:** "å¦‚æœæœåŠ¡å™¨è¢«é»‘,æˆ‘çš„è´¢åŠ¡ä¿¡æ¯ä¼šè¢«çªƒå–å—?"
3. **ç¯¡æ”¹æ‹…å¿§:** "ä¼´ä¾£ä¼šå·å·åˆ é™¤TAçš„æ¶ˆè´¹è®°å½•å—?"
4. **è®¾å¤‡ä¸¢å¤±ææ…Œ:** "æ‰‹æœºä¸¢äº†,æ‰€æœ‰è®°è´¦æ•°æ®éƒ½æ²¡äº†æ€ä¹ˆåŠ?"

**Home Pocketè§£å†³æ–¹æ¡ˆ:**
- æœ¬åœ°ä¼˜å…ˆæ¶æ„,æ•°æ®ä¸ä¸Šä¼ æœåŠ¡å™¨
- ç«¯åˆ°ç«¯åŠ å¯†,å³ä½¿åŒæ­¥ä¹Ÿæ— æ³•è¢«ä¸­é—´äººçªƒå–
- åŒºå—é“¾å¼å“ˆå¸Œé“¾,ä»»ä½•ç¯¡æ”¹éƒ½ä¼šè¢«æ£€æµ‹
- Recovery Kitå¤‡ä»½,æ”¯æŒä»åŠ©è®°è¯æ¢å¤æ‰€æœ‰æ•°æ®

### 1.3 ä¸å…¶ä»–æ¨¡å—çš„ä¾èµ–å…³ç³»

**å‰ç½®ä¾èµ–:**
- æ— ï¼ˆæœ€åŸºç¡€æ¨¡å—,ä¼˜å…ˆå¼€å‘ï¼‰

**è¢«ä¾èµ–:**
- MOD-001 åŸºç¡€è®°è´¦ï¼ˆéœ€è¦åŠ å¯†å­˜å‚¨ï¼‰
- MOD-004 å®¶åº­åŒæ­¥ï¼ˆéœ€è¦å¯†é’¥äº¤æ¢ï¼‰
- MOD-005 OCRæ‰«æï¼ˆéœ€è¦ç…§ç‰‡åŠ å¯†ï¼‰
- æ‰€æœ‰æ¨¡å—ï¼ˆä¾èµ–ç”Ÿç‰©è¯†åˆ«é”å’Œæ•°æ®åº“åŠ å¯†ï¼‰

---

## 2. è¯¦ç»†åŠŸèƒ½è§„æ ¼

### 2.1 E02: å¯†é’¥ç®¡ç†

#### 2.1.1 è®¾å¤‡å¯†é’¥å¯¹ç”Ÿæˆ

**å¯†é’¥ç®—æ³•é€‰æ‹©:**
- **éå¯¹ç§°åŠ å¯†:** Ed25519ï¼ˆæ¤­åœ†æ›²çº¿ç­¾åï¼‰
- **å¯¹ç§°åŠ å¯†:** ChaCha20-Poly1305ï¼ˆå¤‡æ³¨å­—æ®µåŠ å¯†ï¼‰
- **å“ˆå¸Œç®—æ³•:** SHA-256ï¼ˆå“ˆå¸Œé“¾ï¼‰
- **å¯†é’¥æ´¾ç”Ÿ:** PBKDF2ï¼ˆä»Recovery Kitæ´¾ç”Ÿï¼‰

**ä¸ºä»€ä¹ˆé€‰æ‹©Ed25519?**
1. æ€§èƒ½ä¼˜ç§€ï¼ˆæ¯”RSAå¿«10å€ï¼‰
2. å¯†é’¥çŸ­ï¼ˆ32å­—èŠ‚å…¬é’¥ã€64å­—èŠ‚ç­¾åï¼‰
3. å®‰å…¨æ€§é«˜ï¼ˆ128ä½å®‰å…¨çº§åˆ«ï¼‰
4. FlutteråŸç”Ÿæ”¯æŒï¼ˆ`pointycastle`åº“ï¼‰

**å¯†é’¥ç”Ÿæˆæµç¨‹:**

```dart
// lib/core/security/key_manager.dart

import 'package:cryptography/cryptography.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:bip39/bip39.dart' as bip39;

class KeyManager {
  final FlutterSecureStorage _secureStorage;
  final Ed25519 _ed25519 = Ed25519();

  /// ç”Ÿæˆè®¾å¤‡ä¸»å¯†é’¥å¯¹ï¼ˆé¦–æ¬¡å¯åŠ¨æ—¶è°ƒç”¨ï¼‰
  Future<DeviceKeyPair> generateDeviceKeyPair() async {
    // 1. ç”ŸæˆEd25519å¯†é’¥å¯¹
    final keyPair = await _ed25519.newKeyPair();
    final publicKey = await keyPair.extractPublicKey();
    final privateKeyBytes = await keyPair.extractPrivateKeyBytes();

    // 2. å°†ç§é’¥å­˜å‚¨åˆ°å®‰å…¨å­˜å‚¨ï¼ˆiOS Keychain / Android Keystoreï¼‰
    await _secureStorage.write(
      key: 'device_private_key',
      value: base64Encode(privateKeyBytes),
      iOptions: IOSOptions(
        accessibility: KeychainAccessibility.whenUnlockedThisDeviceOnly,
      ),
      aOptions: AndroidOptions(
        encryptedSharedPreferences: true,
      ),
    );

    // 3. å…¬é’¥å¯ä»¥æ˜æ–‡å­˜å‚¨
    final publicKeyHex = base64Encode(publicKey.bytes);
    await _secureStorage.write(
      key: 'device_public_key',
      value: publicKeyHex,
    );

    // 4. ç”Ÿæˆè®¾å¤‡IDï¼ˆå…¬é’¥çš„å“ˆå¸Œï¼‰
    final deviceId = _generateDeviceId(publicKey.bytes);
    await _secureStorage.write(key: 'device_id', value: deviceId);

    return DeviceKeyPair(
      publicKey: publicKeyHex,
      deviceId: deviceId,
      createdAt: DateTime.now(),
    );
  }

  /// ä»Recovery Kitæ¢å¤å¯†é’¥å¯¹
  Future<DeviceKeyPair> recoverFromMnemonic(String mnemonic) async {
    // 1. éªŒè¯åŠ©è®°è¯
    if (!bip39.validateMnemonic(mnemonic)) {
      throw InvalidMnemonicException('åŠ©è®°è¯æ ¼å¼é”™è¯¯');
    }

    // 2. ä»åŠ©è®°è¯æ´¾ç”Ÿç§å­ï¼ˆ512ä½ï¼‰
    final seed = bip39.mnemonicToSeed(mnemonic);

    // 3. å–å‰32å­—èŠ‚ä½œä¸ºEd25519ç§é’¥ç§å­
    final privateKeySeed = seed.sublist(0, 32);

    // 4. ç”Ÿæˆå¯†é’¥å¯¹
    final keyPair = await _ed25519.newKeyPairFromSeed(privateKeySeed);
    final publicKey = await keyPair.extractPublicKey();
    final privateKeyBytes = await keyPair.extractPrivateKeyBytes();

    // 5. å­˜å‚¨åˆ°å®‰å…¨å­˜å‚¨
    await _secureStorage.write(
      key: 'device_private_key',
      value: base64Encode(privateKeyBytes),
    );

    await _secureStorage.write(
      key: 'device_public_key',
      value: base64Encode(publicKey.bytes),
    );

    final deviceId = _generateDeviceId(publicKey.bytes);
    await _secureStorage.write(key: 'device_id', value: deviceId);

    return DeviceKeyPair(
      publicKey: base64Encode(publicKey.bytes),
      deviceId: deviceId,
      createdAt: DateTime.now(),
    );
  }

  /// ç”Ÿæˆè®¾å¤‡IDï¼ˆå…¬é’¥å“ˆå¸Œçš„å‰16å­—ç¬¦ï¼‰
  String _generateDeviceId(List<int> publicKeyBytes) {
    final hash = sha256.convert(publicKeyBytes);
    return base64UrlEncode(hash.bytes).substring(0, 16);
  }

  /// è·å–å½“å‰è®¾å¤‡çš„å…¬é’¥
  Future<String?> getPublicKey() async {
    return await _secureStorage.read(key: 'device_public_key');
  }

  /// è·å–å½“å‰è®¾å¤‡ID
  Future<String?> getDeviceId() async {
    return await _secureStorage.read(key: 'device_id');
  }

  /// æ£€æŸ¥æ˜¯å¦å·²ç”Ÿæˆå¯†é’¥å¯¹
  Future<bool> hasKeyPair() async {
    final privateKey = await _secureStorage.read(key: 'device_private_key');
    return privateKey != null;
  }

  /// ç­¾åæ•°æ®ï¼ˆç”¨äºå“ˆå¸Œé“¾ï¼‰
  Future<Signature> signData(List<int> data) async {
    final privateKeyBase64 = await _secureStorage.read(key: 'device_private_key');
    if (privateKeyBase64 == null) {
      throw KeyNotFoundException('è®¾å¤‡ç§é’¥æœªæ‰¾åˆ°');
    }

    final privateKeyBytes = base64Decode(privateKeyBase64);
    final keyPair = await _ed25519.newKeyPairFromSeed(privateKeyBytes);

    return await _ed25519.sign(data, keyPair: keyPair);
  }

  /// éªŒè¯ç­¾å
  Future<bool> verifySignature({
    required List<int> data,
    required Signature signature,
    required String publicKeyBase64,
  }) async {
    final publicKeyBytes = base64Decode(publicKeyBase64);
    final publicKey = SimplePublicKey(publicKeyBytes, type: KeyPairType.ed25519);

    return await _ed25519.verify(data, signature: signature);
  }
}

class DeviceKeyPair {
  final String publicKey;
  final String deviceId;
  final DateTime createdAt;

  DeviceKeyPair({
    required this.publicKey,
    required this.deviceId,
    required this.createdAt,
  });
}
```

#### 2.1.2 Recovery Kitï¼ˆ24ä¸ªåŠ©è®°è¯ï¼‰

**ä¸ºä»€ä¹ˆä½¿ç”¨BIP39åŠ©è®°è¯?**
- è¡Œä¸šæ ‡å‡†ï¼ˆåŠ å¯†è´§å¸é’±åŒ…å¹¿æ³›é‡‡ç”¨ï¼‰
- æ˜“äºæŠ„å†™å’Œè®°å¿†ï¼ˆç›¸æ¯”éšæœºhexå­—ç¬¦ä¸²ï¼‰
- æ”¯æŒæ ¡éªŒå’Œï¼ˆé˜²æ­¢æŠ„å†™é”™è¯¯ï¼‰

**Recovery Kitç”Ÿæˆæµç¨‹:**

```dart
// lib/core/security/recovery_kit.dart

class RecoveryKitService {
  /// ç”ŸæˆRecovery Kitï¼ˆ24ä¸ªåŠ©è®°è¯ï¼‰
  Future<String> generateRecoveryKit() async {
    // 1. ç”Ÿæˆ256ä½éšæœºç†µ
    final random = Random.secure();
    final entropy = List<int>.generate(32, (_) => random.nextInt(256));

    // 2. è½¬æ¢ä¸ºBIP39åŠ©è®°è¯ï¼ˆ24ä¸ªå•è¯ï¼‰
    final mnemonic = bip39.entropyToMnemonic(Uint8List.fromList(entropy));

    // 3. å­˜å‚¨åˆ°å®‰å…¨å­˜å‚¨ï¼ˆç”¨äºåç»­éªŒè¯ï¼‰
    await _secureStorage.write(
      key: 'recovery_kit_hash',
      value: sha256.convert(utf8.encode(mnemonic)).toString(),
    );

    return mnemonic;
  }

  /// éªŒè¯ç”¨æˆ·è¾“å…¥çš„Recovery Kit
  Future<bool> verifyRecoveryKit(String userInput) async {
    // 1. éªŒè¯BIP39æ ¼å¼
    if (!bip39.validateMnemonic(userInput)) {
      return false;
    }

    // 2. éªŒè¯æ˜¯å¦ä¸å­˜å‚¨çš„å“ˆå¸ŒåŒ¹é…
    final storedHash = await _secureStorage.read(key: 'recovery_kit_hash');
    if (storedHash == null) {
      return false;
    }

    final inputHash = sha256.convert(utf8.encode(userInput)).toString();
    return inputHash == storedHash;
  }

  /// å¯¼å‡ºRecovery Kitä¸ºPDF
  Future<File> exportToPDF(String mnemonic) async {
    final pdf = pw.Document();

    pdf.addPage(
      pw.Page(
        build: (context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Text(
                'Home Pocket Recovery Kit',
                style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
              ),
              pw.SizedBox(height: 20),
              pw.Text(
                'âš ï¸ è¯·å®‰å…¨ä¿å­˜æ­¤æ–‡ä»¶,ä¸¢å¤±å°†æ— æ³•æ¢å¤æ•°æ®',
                style: pw.TextStyle(fontSize: 14, color: PdfColors.red),
              ),
              pw.Divider(),
              pw.SizedBox(height: 20),
              pw.Text('æ‚¨çš„24ä¸ªåŠ©è®°è¯:', style: pw.TextStyle(fontSize: 16)),
              pw.SizedBox(height: 12),
              _buildMnemonicGrid(mnemonic),
              pw.SizedBox(height: 40),
              pw.Text('ç”Ÿæˆæ—¥æœŸ: ${DateFormat('yyyy-MM-dd HH:mm').format(DateTime.now())}'),
              pw.SizedBox(height: 12),
              pw.Text('è®¾å¤‡ID: ${await _keyManager.getDeviceId()}'),
            ],
          );
        },
      ),
    );

    final directory = await getApplicationDocumentsDirectory();
    final file = File('${directory.path}/recovery_kit_${DateTime.now().millisecondsSinceEpoch}.pdf');
    await file.writeAsBytes(await pdf.save());

    return file;
  }

  pw.Widget _buildMnemonicGrid(String mnemonic) {
    final words = mnemonic.split(' ');
    return pw.GridView(
      crossAxisCount: 3,
      childAspectRatio: 3,
      children: List.generate(24, (index) {
        return pw.Container(
          padding: pw.EdgeInsets.all(8),
          decoration: pw.BoxDecoration(
            border: pw.Border.all(color: PdfColors.grey300),
            borderRadius: pw.BorderRadius.circular(4),
          ),
          child: pw.Text(
            '${index + 1}. ${words[index]}',
            style: pw.TextStyle(fontSize: 12),
          ),
        );
      }),
    );
  }
}
```

**UIè®¾è®¡ï¼ˆRecovery Kitå¤‡ä»½é¡µé¢ï¼‰:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Recovery Kit å¤‡ä»½              [X] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  âš ï¸ è¯·æŠ„å†™ä»¥ä¸‹24ä¸ªå•è¯               â”‚
â”‚     ä¸¢å¤±æ­¤å¤‡ä»½å°†æ— æ³•æ¢å¤æ•°æ®         â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. abandon   9. castle     â”‚    â”‚
â”‚  â”‚ 2. ability  10. catalog    â”‚    â”‚
â”‚  â”‚ 3. able     11. catch      â”‚    â”‚
â”‚  â”‚ 4. about    12. category   â”‚    â”‚
â”‚  â”‚ 5. above    13. cattle     â”‚    â”‚
â”‚  â”‚ 6. absent   14. caught     â”‚    â”‚
â”‚  â”‚ 7. absorb   15. cause      â”‚    â”‚
â”‚  â”‚ 8. abstract 16. caution    â”‚    â”‚
â”‚  â”‚ 17. celery  21. change     â”‚    â”‚
â”‚  â”‚ 18. cement  22. chaos      â”‚    â”‚
â”‚  â”‚ 19. census  23. chapter    â”‚    â”‚
â”‚  â”‚ 20. century 24. charge     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚
â”‚  å¯¼å‡ºé€‰é¡¹ï¼š                         â”‚
â”‚  ğŸ“‹ [å¤åˆ¶åˆ°å‰ªè´´æ¿]                  â”‚
â”‚  ğŸ’¾ [ä¿å­˜ä¸ºPDF]                     â”‚
â”‚  ğŸ–¨ï¸ [æ‰“å°]                         â”‚
â”‚                                     â”‚
â”‚  ç¡®è®¤äº‹é¡¹ï¼š                         â”‚
â”‚  â˜ æˆ‘å·²å®‰å…¨ä¿å­˜è¿™äº›å•è¯             â”‚
â”‚  â˜ æˆ‘ç†è§£ä¸¢å¤±åæœ                   â”‚
â”‚  â˜ æˆ‘ä¸ä¼šå‘ä»»ä½•äººæ³„éœ²               â”‚
â”‚                                     â”‚
â”‚  [ä¸‹ä¸€æ­¥]ï¼ˆéœ€å‹¾é€‰å…¨éƒ¨ï¼‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**éªŒè¯é¡µé¢ï¼ˆç¡®ä¿ç”¨æˆ·çœŸçš„æŠ„å†™äº†ï¼‰:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  éªŒè¯ Recovery Kit              â† â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  è¯·è¾“å…¥ä»¥ä¸‹å•è¯ä»¥éªŒè¯æ‚¨å·²æŠ„å†™ï¼š      â”‚
â”‚                                     â”‚
â”‚  ç¬¬3ä¸ªå•è¯ï¼š                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ able                        â”‚    â”‚  â† ç”¨æˆ·è¾“å…¥
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  âœ“ æ­£ç¡®                             â”‚
â”‚                                     â”‚
â”‚  ç¬¬12ä¸ªå•è¯ï¼š                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ category                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  âœ“ æ­£ç¡®                             â”‚
â”‚                                     â”‚
â”‚  ç¬¬24ä¸ªå•è¯ï¼š                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ charge                      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  âœ“ æ­£ç¡®                             â”‚
â”‚                                     â”‚
â”‚  [å®Œæˆè®¾ç½®]                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2.2 E03: ç”Ÿç‰©è¯†åˆ«é”

#### 2.2.1 æ”¯æŒçš„è®¤è¯æ–¹å¼

| å¹³å° | è®¤è¯æ–¹å¼ | å¤‡ç”¨æ–¹æ¡ˆ |
|------|---------|---------|
| iOS | Face ID | Touch ID â†’ PINç  |
| iOS | Touch ID | PINç  |
| Android | äººè„¸è¯†åˆ« | æŒ‡çº¹è¯†åˆ« â†’ PINç  |
| Android | æŒ‡çº¹è¯†åˆ« | PINç  |

**æŠ€æœ¯å®ç°ï¼ˆä½¿ç”¨local_authæ’ä»¶ï¼‰:**

```dart
// lib/core/security/biometric_lock.dart

import 'package:local_auth/local_auth.dart';
import 'package:local_auth_android/local_auth_android.dart';
import 'package:local_auth_ios/local_auth_ios.dart';

class BiometricLock {
  final LocalAuthentication _localAuth = LocalAuthentication();
  int _failedAttempts = 0;
  static const int maxFailedAttempts = 3;

  /// æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒç”Ÿç‰©è¯†åˆ«
  Future<BiometricAvailability> checkAvailability() async {
    // 1. æ£€æŸ¥è®¾å¤‡ç¡¬ä»¶æ”¯æŒ
    final canCheckBiometrics = await _localAuth.canCheckBiometrics;
    final isDeviceSupported = await _localAuth.isDeviceSupported();

    if (!canCheckBiometrics || !isDeviceSupported) {
      return BiometricAvailability.notSupported;
    }

    // 2. è·å–å¯ç”¨çš„ç”Ÿç‰©è¯†åˆ«ç±»å‹
    final availableBiometrics = await _localAuth.getAvailableBiometrics();

    if (availableBiometrics.isEmpty) {
      return BiometricAvailability.notEnrolled;
    }

    // 3. ç¡®å®šå…·ä½“ç±»å‹
    if (availableBiometrics.contains(BiometricType.face)) {
      return BiometricAvailability.faceId;
    } else if (availableBiometrics.contains(BiometricType.fingerprint)) {
      return BiometricAvailability.fingerprint;
    } else if (availableBiometrics.contains(BiometricType.strong) ||
               availableBiometrics.contains(BiometricType.weak)) {
      return BiometricAvailability.generic;
    }

    return BiometricAvailability.notSupported;
  }

  /// æ‰§è¡Œç”Ÿç‰©è¯†åˆ«è®¤è¯
  Future<AuthResult> authenticate({
    required String reason,
    bool allowPINFallback = true,
  }) async {
    try {
      // 1. æ£€æŸ¥å¯ç”¨æ€§
      final availability = await checkAvailability();
      if (availability == BiometricAvailability.notSupported ||
          availability == BiometricAvailability.notEnrolled) {
        return AuthResult.fallbackToPIN();
      }

      // 2. æ£€æŸ¥å¤±è´¥æ¬¡æ•°
      if (_failedAttempts >= maxFailedAttempts) {
        return AuthResult.tooManyAttempts();
      }

      // 3. æ‰§è¡Œè®¤è¯
      final didAuthenticate = await _localAuth.authenticate(
        localizedReason: reason,
        authMessages: [
          AndroidAuthMessages(
            signInTitle: 'Home Pocket èªè¨¼',
            cancelButton: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
            biometricHint: 'æŒ‡ç´‹ã¾ãŸã¯é¡”ã§èªè¨¼',
          ),
          IOSAuthMessages(
            cancelButton: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
            goToSettingsButton: 'è¨­å®š',
            goToSettingsDescription: 'ç”Ÿä½“èªè¨¼ã‚’è¨­å®šã—ã¦ãã ã•ã„',
            lockOut: 'ç”Ÿä½“èªè¨¼ãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ',
          ),
        ],
        options: AuthenticationOptions(
          stickyAuth: true,  // é˜²æ­¢åº”ç”¨åˆ‡æ¢åˆ°åå°æ—¶å–æ¶ˆè®¤è¯
          biometricOnly: !allowPINFallback,  // æ˜¯å¦å…è®¸PINå¤‡ç”¨
          useErrorDialogs: true,
          sensitiveTransaction: true,
        ),
      );

      if (didAuthenticate) {
        _failedAttempts = 0;
        return AuthResult.success();
      } else {
        _failedAttempts++;
        return AuthResult.failed(_failedAttempts);
      }
    } on PlatformException catch (e) {
      if (e.code == 'LockedOut') {
        return AuthResult.lockedOut();
      } else if (e.code == 'NotAvailable') {
        return AuthResult.fallbackToPIN();
      } else {
        _failedAttempts++;
        return AuthResult.error(e.message ?? 'è®¤è¯å¤±è´¥');
      }
    }
  }

  /// é‡ç½®å¤±è´¥æ¬¡æ•°
  void resetFailedAttempts() {
    _failedAttempts = 0;
  }
}

enum BiometricAvailability {
  faceId,
  fingerprint,
  generic,
  notEnrolled,
  notSupported,
}

class AuthResult {
  final AuthStatus status;
  final String? message;
  final int? failedAttempts;

  AuthResult.success()
      : status = AuthStatus.success,
        message = null,
        failedAttempts = null;

  AuthResult.failed(int attempts)
      : status = AuthStatus.failed,
        message = null,
        failedAttempts = attempts;

  AuthResult.fallbackToPIN()
      : status = AuthStatus.fallbackToPIN,
        message = null,
        failedAttempts = null;

  AuthResult.tooManyAttempts()
      : status = AuthStatus.tooManyAttempts,
        message = 'PINã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        failedAttempts = null;

  AuthResult.lockedOut()
      : status = AuthStatus.lockedOut,
        message = 'ç”Ÿä½“èªè¨¼ãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ',
        failedAttempts = null;

  AuthResult.error(String msg)
      : status = AuthStatus.error,
        message = msg,
        failedAttempts = null;
}

enum AuthStatus {
  success,
  failed,
  fallbackToPIN,
  tooManyAttempts,
  lockedOut,
  error,
}
```

#### 2.2.2 å¯åŠ¨è®¤è¯æµç¨‹

```dart
// lib/features/auth/presentation/biometric_lock_screen.dart

class BiometricLockScreen extends ConsumerStatefulWidget {
  @override
  ConsumerState<BiometricLockScreen> createState() => _BiometricLockScreenState();
}

class _BiometricLockScreenState extends ConsumerState<BiometricLockScreen> {
  @override
  void initState() {
    super.initState();
    _authenticate();
  }

  Future<void> _authenticate() async {
    final biometricLock = ref.read(biometricLockProvider);

    final result = await biometricLock.authenticate(
      reason: 'Home Pocketã‚’é–‹ãã«ã¯èªè¨¼ãŒå¿…è¦ã§ã™',
    );

    if (!mounted) return;

    switch (result.status) {
      case AuthStatus.success:
        // è§£å¯†æ•°æ®åº“å¯†é’¥
        await _unlockDatabase();
        // è¿›å…¥é¦–é¡µ
        Navigator.of(context).pushReplacementNamed('/home');
        break;

      case AuthStatus.failed:
        _showFailedDialog(result.failedAttempts!);
        break;

      case AuthStatus.fallbackToPIN:
      case AuthStatus.tooManyAttempts:
        _showPINDialog();
        break;

      case AuthStatus.lockedOut:
        _showLockedOutDialog();
        break;

      case AuthStatus.error:
        _showErrorDialog(result.message!);
        break;
    }
  }

  Future<void> _unlockDatabase() async {
    final keyManager = ref.read(keyManagerProvider);
    final dbPassword = await keyManager.getDatabasePassword();

    // åˆå§‹åŒ–SQLCipher
    final db = ref.read(databaseProvider);
    await db.initialize(password: dbPassword);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.lock, size: 80, color: Theme.of(context).primaryColor),
            SizedBox(height: 24),
            Text(
              'Home Pocket',
              style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 12),
            Text(
              'èªè¨¼ã—ã¦ãã ã•ã„',
              style: TextStyle(fontSize: 16, color: Colors.grey[600]),
            ),
            SizedBox(height: 40),
            CircularProgressIndicator(),
            SizedBox(height: 20),
            TextButton(
              onPressed: _showPINDialog,
              child: Text('PINã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›'),
            ),
          ],
        ),
      ),
    );
  }

  void _showFailedDialog(int attempts) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('èªè¨¼å¤±æ•—'),
        content: Text('èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆ${attempts}/${BiometricLock.maxFailedAttempts}å›ï¼‰'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _authenticate();
            },
            child: Text('å†è©¦è¡Œ'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _showPINDialog();
            },
            child: Text('PINã‚’å…¥åŠ›'),
          ),
        ],
      ),
    );
  }

  void _showPINDialog() {
    // TODO: å®ç°PINè¾“å…¥å¯¹è¯æ¡†
    // éªŒè¯PINåè°ƒç”¨_unlockDatabase()
  }
}
```

---

### 2.3 D03: å“ˆå¸Œé“¾å®¡è®¡

#### 2.3.1 å“ˆå¸Œé“¾åŸç†

**åŒºå—é“¾å¼é˜²ç¯¡æ”¹:**
æ¯ç¬”äº¤æ˜“åŒ…å«å‰ä¸€ç¬”äº¤æ˜“çš„å“ˆå¸Œå€¼,å½¢æˆé“¾å¼ç»“æ„ã€‚ä»»ä½•ä¿®æ”¹éƒ½ä¼šå¯¼è‡´åç»­å“ˆå¸Œå€¼å…¨éƒ¨æ”¹å˜,ä»è€Œè¢«æ£€æµ‹ã€‚

```
Genesis (åˆ›ä¸–è®°å½•)
    â†“
tx-001 [hash: abc123, prevHash: genesis]
    â†“
tx-002 [hash: def456, prevHash: abc123]
    â†“
tx-003 [hash: ghi789, prevHash: def456]
    â†“
...
```

**å“ˆå¸Œè®¡ç®—:**

```dart
// lib/core/security/hash_chain_service.dart

class HashChainService {
  final KeyManager _keyManager;
  final TransactionRepository _transactionRepo;

  /// è®¡ç®—äº¤æ˜“å“ˆå¸Œ
  Future<String> calculateHash(Transaction tx) async {
    // 1. è·å–å‰ä¸€ç¬”äº¤æ˜“çš„å“ˆå¸Œ
    final prevHash = tx.prevHash ?? 'genesis';

    // 2. æ„é€ å¾…å“ˆå¸Œæ•°æ®ï¼ˆåŒ…å«å…³é”®å­—æ®µï¼‰
    final data = StringBuffer()
      ..write(tx.id)
      ..write('|')
      ..write(tx.bookId)
      ..write('|')
      ..write(tx.deviceId)
      ..write('|')
      ..write(tx.amount)
      ..write('|')
      ..write(tx.type.name)
      ..write('|')
      ..write(tx.categoryId)
      ..write('|')
      ..write(tx.ledgerType.name)
      ..write('|')
      ..write(tx.timestamp.millisecondsSinceEpoch)
      ..write('|')
      ..write(prevHash);

    // 3. SHA-256å“ˆå¸Œ
    final bytes = utf8.encode(data.toString());
    final digest = sha256.convert(bytes);

    // 4. Base64ç¼–ç ï¼ˆä¾¿äºå­˜å‚¨ï¼‰
    return base64Encode(digest.bytes);
  }

  /// éªŒè¯æ•´ä¸ªå“ˆå¸Œé“¾çš„å®Œæ•´æ€§
  Future<ChainVerificationResult> verifyChain(String bookId) async {
    final transactions = await _transactionRepo.getTransactions(
      bookId: bookId,
      orderBy: 'timestamp ASC',
    );

    if (transactions.isEmpty) {
      return ChainVerificationResult.empty();
    }

    String prevHash = 'genesis';
    final tamperedTransactions = <Transaction>[];

    for (var i = 0; i < transactions.length; i++) {
      final tx = transactions[i];

      // 1. éªŒè¯prevHashæ˜¯å¦æ­£ç¡®
      if (tx.prevHash != prevHash) {
        tamperedTransactions.add(tx);
        continue;
      }

      // 2. é‡æ–°è®¡ç®—å“ˆå¸Œå¹¶æ¯”å¯¹
      final expectedHash = await calculateHash(
        tx.copyWith(prevHash: prevHash),
      );

      if (tx.currentHash != expectedHash) {
        tamperedTransactions.add(tx);
      }

      prevHash = tx.currentHash;
    }

    if (tamperedTransactions.isEmpty) {
      return ChainVerificationResult.valid(
        totalTransactions: transactions.length,
      );
    } else {
      return ChainVerificationResult.tampered(
        totalTransactions: transactions.length,
        tamperedTransactions: tamperedTransactions,
      );
    }
  }

  /// æ·»åŠ æ–°äº¤æ˜“åˆ°é“¾ä¸­
  Future<Transaction> appendToChain({
    required Transaction tx,
    required String bookId,
  }) async {
    // 1. è·å–æœ€åä¸€ç¬”äº¤æ˜“
    final lastTx = await _transactionRepo.getLastTransaction(bookId);

    // 2. è®¾ç½®prevHash
    final prevHash = lastTx?.currentHash ?? 'genesis';

    // 3. è®¡ç®—å½“å‰å“ˆå¸Œ
    final currentHash = await calculateHash(
      tx.copyWith(prevHash: prevHash),
    );

    // 4. è¿”å›å®Œæ•´çš„äº¤æ˜“å¯¹è±¡
    return tx.copyWith(
      prevHash: prevHash,
      currentHash: currentHash,
    );
  }
}

class ChainVerificationResult {
  final bool isValid;
  final int totalTransactions;
  final List<Transaction> tamperedTransactions;

  ChainVerificationResult.valid({
    required this.totalTransactions,
  })  : isValid = true,
        tamperedTransactions = [];

  ChainVerificationResult.tampered({
    required this.totalTransactions,
    required this.tamperedTransactions,
  }) : isValid = false;

  ChainVerificationResult.empty()
      : isValid = true,
        totalTransactions = 0,
        tamperedTransactions = [];
}
```

#### 2.3.2 å®¡è®¡æ—¥å¿—æŸ¥çœ‹å™¨

**UIè®¾è®¡:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å“ˆå¸Œé“¾å®Œæ•´æ€§éªŒè¯                â† â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è´¦æœ¬ï¼šæˆ‘ä»¬çš„å°çª                    â”‚
â”‚  äº¤æ˜“æ€»æ•°ï¼š1,234ç¬”                   â”‚
â”‚  æœ€åéªŒè¯ï¼š2026/2/3 14:30           â”‚
â”‚                                     â”‚
â”‚  éªŒè¯ç»“æœï¼šâœ… å®Œæ•´                   â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚                                     â”‚
â”‚  å“ˆå¸Œé“¾å¯è§†åŒ–ï¼š                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Genesis                     â”‚    â”‚
â”‚  â”‚   â†“                         â”‚    â”‚
â”‚  â”‚ tx-001 [âœ“]                  â”‚    â”‚
â”‚  â”‚ abc123def456789...          â”‚    â”‚
â”‚  â”‚   â†“                         â”‚    â”‚
â”‚  â”‚ tx-002 [âœ“]                  â”‚    â”‚
â”‚  â”‚ def456ghi789abc...          â”‚    â”‚
â”‚  â”‚   â†“                         â”‚    â”‚
â”‚  â”‚ tx-003 [âœ“]                  â”‚    â”‚
â”‚  â”‚ ghi789jkl012def...          â”‚    â”‚
â”‚  â”‚   â†“                         â”‚    â”‚
â”‚  â”‚ ...                         â”‚    â”‚
â”‚  â”‚   â†“                         â”‚    â”‚
â”‚  â”‚ tx-1234 [âœ“]                 â”‚    â”‚
â”‚  â”‚ xyz987uvw654pqr...          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚
â”‚  [é‡æ–°éªŒè¯]                         â”‚
â”‚  [å¯¼å‡ºå®¡è®¡æŠ¥å‘ŠPDF]                  â”‚
â”‚                                     â”‚
â”‚  âš ï¸ å¦‚æ£€æµ‹åˆ°ç¯¡æ”¹ï¼Œå“ˆå¸Œé“¾ä¼šæ˜¾ç¤º      â”‚
â”‚     çº¢è‰²è­¦å‘Šï¼Œå¹¶æ ‡è®°å—å½±å“çš„è®°å½•     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç¯¡æ”¹æ£€æµ‹å±•ç¤º:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å“ˆå¸Œé“¾å®Œæ•´æ€§éªŒè¯                â† â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  éªŒè¯ç»“æœï¼šâŒ æ£€æµ‹åˆ°ç¯¡æ”¹             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚                                     â”‚
â”‚  å—å½±å“çš„äº¤æ˜“ï¼š                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ tx-042 [âŒ]                 â”‚    â”‚  â† çº¢è‰²æ ‡è®°
â”‚  â”‚ é‡‘é¢ï¼šÂ¥5,000 â†’ Â¥500ï¼Ÿ      â”‚    â”‚
â”‚  â”‚ å“ˆå¸Œä¸åŒ¹é…                  â”‚    â”‚
â”‚  â”‚ é¢„æœŸï¼šdef456...             â”‚    â”‚
â”‚  â”‚ å®é™…ï¼šabc123...             â”‚    â”‚
â”‚  â”‚                             â”‚    â”‚
â”‚  â”‚ tx-043 [âŒ]                 â”‚    â”‚
â”‚  â”‚ é“¾å¼å½±å“ï¼ˆåç»­å…¨éƒ¨å¤±æ•ˆï¼‰     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚
â”‚  å¯èƒ½åŸå› ï¼š                         â”‚
â”‚  â€¢ æ•°æ®åº“æ–‡ä»¶è¢«ç›´æ¥ä¿®æ”¹             â”‚
â”‚  â€¢ è®¾å¤‡æ—¶é—´è¢«è°ƒæ•´                   â”‚
â”‚  â€¢ æ¶æ„åº”ç”¨ç¯¡æ”¹                     â”‚
â”‚                                     â”‚
â”‚  å»ºè®®æ“ä½œï¼š                         â”‚
â”‚  [æŸ¥çœ‹è¯¦ç»†æ—¥å¿—]                     â”‚
â”‚  [æ¢å¤å¤‡ä»½]                         â”‚
â”‚  [è”ç³»æ”¯æŒ]                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.3.3 PDFå®¡è®¡æŠ¥å‘Š

```dart
// lib/features/audit/use_cases/export_audit_report.dart

class ExportAuditReportUseCase {
  final HashChainService _hashChain;
  final TransactionRepository _transactionRepo;
  final KeyManager _keyManager;

  Future<File> execute(String bookId) async {
    // 1. éªŒè¯å“ˆå¸Œé“¾
    final verification = await _hashChain.verifyChain(bookId);

    // 2. è·å–æ‰€æœ‰äº¤æ˜“
    final transactions = await _transactionRepo.getTransactions(
      bookId: bookId,
      orderBy: 'timestamp ASC',
    );

    // 3. ç”ŸæˆPDF
    final pdf = pw.Document();

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        build: (context) => [
          _buildHeader(),
          pw.SizedBox(height: 20),
          _buildSummary(bookId, verification),
          pw.SizedBox(height: 20),
          _buildChainVisualization(transactions, verification),
          pw.SizedBox(height: 20),
          _buildSignature(),
        ],
      ),
    );

    // 4. ä¿å­˜æ–‡ä»¶
    final directory = await getApplicationDocumentsDirectory();
    final file = File(
      '${directory.path}/audit_report_${DateTime.now().millisecondsSinceEpoch}.pdf',
    );
    await file.writeAsBytes(await pdf.save());

    return file;
  }

  pw.Widget _buildHeader() {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Text(
          'Home Pocket å¯©è¨ˆå ±å‘Š',
          style: pw.TextStyle(fontSize: 28, fontWeight: pw.FontWeight.bold),
        ),
        pw.Text(
          'ç”Ÿæˆæ™‚é–“ï¼š${DateFormat('yyyyå¹´MMæœˆddæ—¥ HH:mm').format(DateTime.now())}',
          style: pw.TextStyle(fontSize: 12, color: PdfColors.grey),
        ),
      ],
    );
  }

  pw.Widget _buildSummary(String bookId, ChainVerificationResult verification) {
    return pw.Container(
      padding: pw.EdgeInsets.all(16),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.grey300),
        borderRadius: pw.BorderRadius.circular(8),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text('å¸³ç°¿æƒ…å ±', style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
          pw.Divider(),
          pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text('å¸³ç°¿IDï¼š'),
              pw.Text(bookId),
            ],
          ),
          pw.SizedBox(height: 8),
          pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text('ç·å–å¼•æ•°ï¼š'),
              pw.Text('${verification.totalTransactions}ç­†'),
            ],
          ),
          pw.SizedBox(height: 8),
          pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text('æ¤œè¨¼çŠ¶æ…‹ï¼š'),
              pw.Text(
                verification.isValid ? 'âœ… å®Œå…¨' : 'âŒ æ”¹ã–ã‚“æ¤œå‡º',
                style: pw.TextStyle(
                  color: verification.isValid ? PdfColors.green : PdfColors.red,
                  fontWeight: pw.FontWeight.bold,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  pw.Widget _buildChainVisualization(
    List<Transaction> transactions,
    ChainVerificationResult verification,
  ) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Text('å®Œå…¨ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³', style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
        pw.SizedBox(height: 12),
        ...transactions.take(50).map((tx) {
          final isTampered = verification.tamperedTransactions.contains(tx);
          return _buildTransactionRow(tx, isTampered);
        }),
        if (transactions.length > 50)
          pw.Text('... (${transactions.length - 50}ç­†çœç•¥)'),
      ],
    );
  }

  pw.Widget _buildTransactionRow(Transaction tx, bool isTampered) {
    return pw.Container(
      margin: pw.EdgeInsets.only(bottom: 8),
      padding: pw.EdgeInsets.all(8),
      decoration: pw.BoxDecoration(
        color: isTampered ? PdfColors.red50 : PdfColors.grey100,
        borderRadius: pw.BorderRadius.circular(4),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text(
                '${DateFormat('yyyy/MM/dd HH:mm').format(tx.timestamp)}',
                style: pw.TextStyle(fontSize: 10),
              ),
              pw.Text(
                'Â¥${_formatAmount(tx.amount)}',
                style: pw.TextStyle(fontSize: 10, fontWeight: pw.FontWeight.bold),
              ),
            ],
          ),
          pw.SizedBox(height: 4),
          pw.Text('Hash: ${tx.currentHash.substring(0, 32)}...', style: pw.TextStyle(fontSize: 8)),
          pw.Text('PrevHash: ${tx.prevHash?.substring(0, 32) ?? 'genesis'}...', style: pw.TextStyle(fontSize: 8)),
          if (isTampered)
            pw.Text(
              'âš ï¸ æ”¹ã–ã‚“æ¤œå‡º',
              style: pw.TextStyle(fontSize: 8, color: PdfColors.red),
            ),
        ],
      ),
    );
  }

  pw.Widget _buildSignature() async {
    final deviceId = await _keyManager.getDeviceId();
    final publicKey = await _keyManager.getPublicKey();

    return pw.Container(
      padding: pw.EdgeInsets.all(16),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.grey300),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text('ç½²åæƒ…å ±', style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
          pw.Divider(),
          pw.Text('æœ¬å ±å‘Šæ›¸ã¯ä»¥ä¸‹ã®ãƒ‡ãƒã‚¤ã‚¹ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼š'),
          pw.SizedBox(height: 8),
          pw.Text('ãƒ‡ãƒã‚¤ã‚¹ID: $deviceId', style: pw.TextStyle(fontSize: 10)),
          pw.Text('å…¬é–‹éµæŒ‡ç´‹: ${_formatFingerprint(publicKey!)}', style: pw.TextStyle(fontSize: 10)),
          pw.SizedBox(height: 8),
          pw.Text(
            'âš ï¸ ã“ã®PDFã¯å‚ç…§ç”¨ã§ã™ã€‚æ”¹ã–ã‚“ã®è¨¼æ˜ã¨ã—ã¦ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚',
            style: pw.TextStyle(fontSize: 8, color: PdfColors.grey),
          ),
        ],
      ),
    );
  }

  String _formatFingerprint(String publicKey) {
    final hash = sha256.convert(base64Decode(publicKey));
    final hex = hash.bytes.map((b) => b.toRadixString(16).padLeft(2, '0')).join('');
    return hex.toUpperCase().replaceAllMapped(
      RegExp(r'.{2}'),
      (match) => '${match.group(0)}:',
    ).substring(0, 59);  // AB:CD:EF:12:34:56:...
  }

  String _formatAmount(int amount) {
    final formatter = NumberFormat('#,###', 'ja_JP');
    return formatter.format(amount);
  }
}
```

---

### 2.4 E01: éšç§å®£è¨€å¼•å¯¼

#### 2.4.1 ä¸‰é¡µå¼•å¯¼è®¾è®¡

**ç¬¬1é¡µï¼šéšç§æ‰¿è¯º**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                     â”‚
â”‚           ğŸ”’                        â”‚
â”‚                                     â”‚
â”‚       ã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã¯                â”‚
â”‚       ã‚ãªãŸã ã‘ã®ã‚‚ã®                â”‚
â”‚                                     â”‚
â”‚  â€¢ ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ã•ã‚Œã¾ã›ã‚“         â”‚
â”‚  â€¢ ä¼šç¤¾ã¯è¦‹ã‚‰ã‚Œã¾ã›ã‚“               â”‚
â”‚  â€¢ ç«¯åˆ°ç«¯åŠ å¯†ã§ä¿è­·                 â”‚
â”‚                                     â”‚
â”‚       â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”          â”‚
â”‚       æˆ‘ä»¬æ°¸ä¸:                      â”‚
â”‚       âŒ ä¸Šä¼ ä½ çš„æ•°æ®åˆ°æœåŠ¡å™¨        â”‚
â”‚       âŒ å‡ºå”®ä½ çš„è´¢åŠ¡ä¿¡æ¯            â”‚
â”‚       âŒ è¿½è¸ªä½ çš„æ¶ˆè´¹ä¹ æƒ¯            â”‚
â”‚                                     â”‚
â”‚              â—‹ â—‹ â—‹                â”‚
â”‚                                     â”‚
â”‚                          [æ¬¡ã¸] â†’  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç¬¬2é¡µï¼šé˜²ç¯¡æ”¹æ‰¿è¯º**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                     â”‚
â”‚           â›“ï¸                        â”‚
â”‚                                     â”‚
â”‚       æ”¹ã–ã‚“ã§ããªã„è¨˜éŒ²              â”‚
â”‚                                     â”‚
â”‚  â€¢ ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³æŠ€è¡“ã‚’ä½¿ç”¨       â”‚
â”‚  â€¢ ã™ã¹ã¦ã®è¨˜éŒ²ãŒæš—å·åŒ–              â”‚
â”‚  â€¢ èª°ã‚‚éå»ã‚’å¤‰ãˆã‚‰ã‚Œã¾ã›ã‚“         â”‚
â”‚                                     â”‚
â”‚       â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”          â”‚
â”‚       åŒºå—é“¾å¼é˜²ç¯¡æ”¹:                â”‚
â”‚       âœ“ æ¯ç¬”äº¤æ˜“éƒ½æœ‰å“ˆå¸Œç­¾å         â”‚
â”‚       âœ“ ä»»ä½•ä¿®æ”¹éƒ½ä¼šè¢«æ£€æµ‹           â”‚
â”‚       âœ“ å®Œæ•´å®¡è®¡æ—¥å¿—å¯å¯¼å‡º           â”‚
â”‚                                     â”‚
â”‚              â—‹ â—‹ â—‹                â”‚
â”‚                                     â”‚
â”‚  [æˆ»ã‚‹] â†                [æ¬¡ã¸] â†’  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç¬¬3é¡µï¼šå¼€æºæ‰¿è¯º**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                     â”‚
â”‚           ğŸ‘ï¸                        â”‚
â”‚                                     â”‚
â”‚       é€æ˜ã§ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹            â”‚
â”‚                                     â”‚
â”‚  â€¢ ã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨å…¬é–‹                 â”‚
â”‚  â€¢ èª°ã§ã‚‚æ¤œè¨¼ã§ãã¾ã™               â”‚
â”‚  â€¢ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨ä¸€ç·’ã«             â”‚
â”‚                                     â”‚
â”‚       â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”          â”‚
â”‚       å¼€æºé€æ˜:                      â”‚
â”‚       âœ“ æºä»£ç å®Œå…¨å…¬å¼€               â”‚
â”‚       âœ“ å®‰å…¨ä¸“å®¶å¯å®¡è®¡               â”‚
â”‚       âœ“ ç¤¾åŒºé©±åŠ¨å¼€å‘                 â”‚
â”‚                                     â”‚
â”‚  GitHub: github.com/homepocket     â”‚
â”‚                                     â”‚
â”‚              â—‹ â—‹ â—‹                â”‚
â”‚                                     â”‚
â”‚  [æˆ»ã‚‹] â†              [å§‹ã‚ã‚‹] â†’  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å®ç°ä»£ç :**

```dart
// lib/features/onboarding/presentation/privacy_onboarding_screen.dart

class PrivacyOnboardingScreen extends StatefulWidget {
  @override
  State<PrivacyOnboardingScreen> createState() => _PrivacyOnboardingScreenState();
}

class _PrivacyOnboardingScreenState extends State<PrivacyOnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: PageView(
                controller: _pageController,
                onPageChanged: (index) => setState(() => _currentPage = index),
                children: [
                  _buildPrivacyPage(),
                  _buildTamperproofPage(),
                  _buildOpenSourcePage(),
                ],
              ),
            ),
            _buildPageIndicator(),
            SizedBox(height: 20),
            _buildNavigationButtons(),
            SizedBox(height: 40),
          ],
        ),
      ),
    );
  }

  Widget _buildPrivacyPage() {
    return Padding(
      padding: EdgeInsets.all(32),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.lock, size: 100, color: Color(0xFF4A90D9)),
          SizedBox(height: 40),
          Text(
            'ã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã¯\nã‚ãªãŸã ã‘ã®ã‚‚ã®',
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 40),
          _buildFeatureItem('ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ã•ã‚Œã¾ã›ã‚“'),
          _buildFeatureItem('ä¼šç¤¾ã¯è¦‹ã‚‰ã‚Œã¾ã›ã‚“'),
          _buildFeatureItem('ç«¯åˆ°ç«¯åŠ å¯†ã§ä¿è­·'),
          SizedBox(height: 40),
          Container(
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.grey[100],
              borderRadius: BorderRadius.circular(12),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('æˆ‘ä»¬æ°¸ä¸:', style: TextStyle(fontWeight: FontWeight.bold)),
                SizedBox(height: 8),
                _buildNeverItem('ä¸Šä¼ ä½ çš„æ•°æ®åˆ°æœåŠ¡å™¨'),
                _buildNeverItem('å‡ºå”®ä½ çš„è´¢åŠ¡ä¿¡æ¯'),
                _buildNeverItem('è¿½è¸ªä½ çš„æ¶ˆè´¹ä¹ æƒ¯'),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFeatureItem(String text) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8),
      child: Row(
        children: [
          Icon(Icons.check_circle, color: Colors.green, size: 24),
          SizedBox(width: 12),
          Expanded(
            child: Text(text, style: TextStyle(fontSize: 16)),
          ),
        ],
      ),
    );
  }

  Widget _buildNeverItem(String text) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(Icons.close, color: Colors.red, size: 20),
          SizedBox(width: 8),
          Expanded(
            child: Text(text, style: TextStyle(fontSize: 14)),
          ),
        ],
      ),
    );
  }

  Widget _buildPageIndicator() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: List.generate(3, (index) {
        return Container(
          margin: EdgeInsets.symmetric(horizontal: 4),
          width: _currentPage == index ? 24 : 8,
          height: 8,
          decoration: BoxDecoration(
            color: _currentPage == index ? Color(0xFF4A90D9) : Colors.grey[300],
            borderRadius: BorderRadius.circular(4),
          ),
        );
      }),
    );
  }

  Widget _buildNavigationButtons() {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: 32),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          if (_currentPage > 0)
            TextButton(
              onPressed: () => _pageController.previousPage(
                duration: Duration(milliseconds: 300),
                curve: Curves.easeInOut,
              ),
              child: Text('â† æˆ»ã‚‹'),
            )
          else
            SizedBox(width: 80),
          ElevatedButton(
            onPressed: _currentPage == 2 ? _onComplete : _onNext,
            child: Text(_currentPage == 2 ? 'å§‹ã‚ã‚‹' : 'æ¬¡ã¸ â†’'),
          ),
        ],
      ),
    );
  }

  void _onNext() {
    _pageController.nextPage(
      duration: Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  void _onComplete() async {
    // æ ‡è®°å¼•å¯¼å·²å®Œæˆ
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('privacy_onboarding_completed', true);

    // è¿›å…¥å¯†é’¥ç”Ÿæˆé¡µé¢
    if (!mounted) return;
    Navigator.of(context).pushReplacementNamed('/setup_keys');
  }
}
```

---

### 2.5 æ•°æ®åŠ å¯†

#### 2.5.1 SQLCipheræ•°æ®åº“åŠ å¯†

```dart
// lib/core/database/encrypted_database.dart

class EncryptedDatabase {
  late Database _database;
  final KeyManager _keyManager;

  /// åˆå§‹åŒ–åŠ å¯†æ•°æ®åº“
  Future<void> initialize({String? password}) async {
    final dbPassword = password ?? await _keyManager.getDatabasePassword();

    final databasesPath = await getDatabasesPath();
    final path = join(databasesPath, 'homepocket.db');

    _database = await openDatabase(
      path,
      version: 1,
      onCreate: _onCreate,
      onOpen: (db) async {
        // è®¾ç½®SQLCipherå¯†é’¥
        await db.rawQuery('PRAGMA key = "$dbPassword"');

        // éªŒè¯å¯†é’¥æ˜¯å¦æ­£ç¡®
        try {
          await db.rawQuery('SELECT count(*) FROM sqlite_master');
        } catch (e) {
          throw DatabasePasswordException('æ•°æ®åº“å¯†ç é”™è¯¯');
        }

        // æ€§èƒ½ä¼˜åŒ–è®¾ç½®
        await db.rawQuery('PRAGMA cipher_page_size = 4096');
        await db.rawQuery('PRAGMA kdf_iter = 256000');  // PBKDF2è¿­ä»£æ¬¡æ•°
        await db.rawQuery('PRAGMA cipher_hmac_algorithm = HMAC_SHA512');
        await db.rawQuery('PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA512');
      },
    );
  }

  /// ç”Ÿæˆæ•°æ®åº“å¯†ç ï¼ˆä»è®¾å¤‡å¯†é’¥æ´¾ç”Ÿï¼‰
  Future<String> generateDatabasePassword() async {
    final privateKey = await _keyManager.getPrivateKey();
    if (privateKey == null) {
      throw KeyNotFoundException('è®¾å¤‡ç§é’¥æœªæ‰¾åˆ°');
    }

    // ä½¿ç”¨PBKDF2ä»ç§é’¥æ´¾ç”Ÿæ•°æ®åº“å¯†ç 
    final salt = utf8.encode('homepocket_db_salt');  // å›ºå®šç›å€¼
    final derivedKey = await Pbkdf2(
      macAlgorithm: Hmac.sha256(),
      iterations: 100000,
      bits: 256,
    ).deriveKey(
      secretKey: SecretKey(base64Decode(privateKey)),
      nonce: salt,
    );

    final keyBytes = await derivedKey.extractBytes();
    return base64Encode(keyBytes);
  }
}
```

#### 2.5.2 å¤‡æ³¨å­—æ®µåŠ å¯†ï¼ˆChaCha20-Poly1305ï¼‰

```dart
// lib/core/security/encryption_service.dart

class EncryptionService {
  final KeyManager _keyManager;
  final ChaCha20 _chacha20 = ChaCha20.poly1305Aead();

  /// åŠ å¯†å¤‡æ³¨å­—æ®µ
  Future<String> encrypt(String plaintext) async {
    // 1. è·å–åŠ å¯†å¯†é’¥
    final encryptionKey = await _getEncryptionKey();

    // 2. ç”Ÿæˆéšæœºnonceï¼ˆ12å­—èŠ‚ï¼‰
    final nonce = _generateNonce();

    // 3. åŠ å¯†
    final secretBox = await _chacha20.encrypt(
      utf8.encode(plaintext),
      secretKey: encryptionKey,
      nonce: nonce,
    );

    // 4. ç»„åˆnonce + ciphertext + mac
    final combined = <int>[]
      ..addAll(nonce)
      ..addAll(secretBox.cipherText)
      ..addAll(secretBox.mac.bytes);

    // 5. Base64ç¼–ç 
    return base64Encode(combined);
  }

  /// è§£å¯†å¤‡æ³¨å­—æ®µ
  Future<String> decrypt(String ciphertext) async {
    // 1. Base64è§£ç 
    final combined = base64Decode(ciphertext);

    // 2. åˆ†ç¦»nonce, ciphertext, mac
    final nonce = combined.sublist(0, 12);
    final ciphertextBytes = combined.sublist(12, combined.length - 16);
    final mac = Mac(combined.sublist(combined.length - 16));

    // 3. è·å–åŠ å¯†å¯†é’¥
    final encryptionKey = await _getEncryptionKey();

    // 4. è§£å¯†
    final secretBox = SecretBox(ciphertextBytes, nonce: nonce, mac: mac);
    final plaintext = await _chacha20.decrypt(
      secretBox,
      secretKey: encryptionKey,
    );

    return utf8.decode(plaintext);
  }

  /// ä»è®¾å¤‡å¯†é’¥æ´¾ç”ŸåŠ å¯†å¯†é’¥
  Future<SecretKey> _getEncryptionKey() async {
    final privateKey = await _keyManager.getPrivateKey();
    if (privateKey == null) {
      throw KeyNotFoundException('è®¾å¤‡ç§é’¥æœªæ‰¾åˆ°');
    }

    // ä½¿ç”¨HKDFä»ç§é’¥æ´¾ç”ŸåŠ å¯†å¯†é’¥
    final hkdf = Hkdf(
      hmac: Hmac(Sha256()),
      outputLength: 32,  // 256ä½
    );

    final derivedKey = await hkdf.deriveKey(
      secretKey: SecretKey(base64Decode(privateKey)),
      info: utf8.encode('homepocket_note_encryption'),  // ä¸Šä¸‹æ–‡ä¿¡æ¯
      nonce: [],
    );

    return derivedKey;
  }

  List<int> _generateNonce() {
    final random = Random.secure();
    return List.generate(12, (_) => random.nextInt(256));
  }
}
```

---

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 å®‰å…¨ç›¸å…³è¡¨å®šä¹‰

```dart
// lib/core/database/tables.dart

@DataClassName('DeviceData')
class Devices extends Table {
  TextColumn get id => text()();  // è®¾å¤‡IDï¼ˆå…¬é’¥å“ˆå¸Œï¼‰
  TextColumn get publicKey => text()();  // Ed25519å…¬é’¥ï¼ˆBase64ï¼‰
  TextColumn get name => text()();  // è®¾å¤‡æ˜µç§°ï¼ˆå¦‚"æˆ‘çš„iPhone"ï¼‰
  IntColumn get createdAt => integer()();
  IntColumn get lastSeenAt => integer()();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('RecoveryKitData')
class RecoveryKits extends Table {
  TextColumn get id => text()();
  TextColumn get deviceId => text()();
  TextColumn get mnemonicHash => text()();  // åŠ©è®°è¯å“ˆå¸Œï¼ˆä¸å­˜å‚¨æ˜æ–‡ï¼ï¼‰
  BoolColumn get isVerified => boolean().withDefault(const Constant(false))();
  IntColumn get createdAt => integer()();
  IntColumn get verifiedAt => integer().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('AuditLogData')
class AuditLogs extends Table {
  TextColumn get id => text()();
  TextColumn get bookId => text()();
  TextColumn get eventType => text()();  // 'chain_verified', 'tamper_detected', 'key_rotated'
  TextColumn get details => text().nullable()();  // JSONæ ¼å¼è¯¦ç»†ä¿¡æ¯
  IntColumn get timestamp => integer()();

  @override
  Set<Column> get primaryKey => {id};
}
```

### 3.2 å®ä½“å…³ç³»å›¾ï¼ˆERDï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Devices       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚
â”‚ publicKey       â”‚â”€â”€â”
â”‚ name            â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                     â”‚  å…³è”
                     â†“
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ RecoveryKits     â”‚
          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ deviceId (FK)    â”‚
          â”‚ mnemonicHash     â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Transactions    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚
â”‚ prevHash        â”‚  â† å“ˆå¸Œé“¾
â”‚ currentHash     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ AuditLogs        â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ eventType        â”‚
   â”‚ details          â”‚  â† è®°å½•éªŒè¯ç»“æœ
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. UI/UXè®¾è®¡

### 4.1 è®¾ç½®é¡µé¢ï¼ˆå®‰å…¨é€‰é¡¹ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â† è®¾ç½®                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [ç”¨æˆ·å¤´åƒ]                         â”‚
â”‚  å¤ªéƒ                               â”‚
â”‚  taro@example.com                   â”‚
â”‚                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚  å®‰å…¨ä¸éšç§                         â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚                                     â”‚
â”‚  ğŸ”’ ç”Ÿç‰©è¯†åˆ«é”                      â”‚
â”‚  [Face ID                     âœ“]   â”‚  â† å¼€å…³
â”‚                                     â”‚
â”‚  ğŸ”‘ Recovery Kit                   â”‚
â”‚  [æŸ¥çœ‹å¤‡ä»½] [éªŒè¯å¤‡ä»½]              â”‚
â”‚                                     â”‚
â”‚  â›“ï¸ å“ˆå¸Œé“¾å®¡è®¡                      â”‚
â”‚  [éªŒè¯å®Œæ•´æ€§] [å¯¼å‡ºæŠ¥å‘Š]            â”‚
â”‚                                     â”‚
â”‚  ğŸ” å¯†é’¥ç®¡ç†                        â”‚
â”‚  è®¾å¤‡ID: abc123def456               â”‚
â”‚  å…¬é’¥æŒ‡çº¹: AB:CD:EF:12:34:56       â”‚
â”‚  [æŸ¥çœ‹è¯¦æƒ…]                         â”‚
â”‚                                     â”‚
â”‚  ğŸ“„ éšç§æ”¿ç­–                        â”‚
â”‚  [æŸ¥çœ‹å®Œæ•´æ”¿ç­–]                     â”‚
â”‚                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚  æ•°æ®ç®¡ç†                           â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚                                     â”‚
â”‚  ğŸ’¾ æœ¬åœ°æ•°æ®                        â”‚
â”‚  æ•°æ®åº“å¤§å°: 2.3 MB                 â”‚
â”‚  äº¤æ˜“æ•°é‡: 1,234ç¬”                  â”‚
â”‚  [æ¸…é™¤ç¼“å­˜]                         â”‚
â”‚                                     â”‚
â”‚  ğŸ—‘ï¸ åˆ é™¤æ‰€æœ‰æ•°æ®                   â”‚
â”‚  [æ°¸ä¹…åˆ é™¤ï¼ˆä¸å¯æ¢å¤ï¼‰]             â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 5.1 çŠ¶æ€ç®¡ç†ï¼ˆRiverpodï¼‰

```dart
// lib/core/security/providers/security_providers.dart

final keyManagerProvider = Provider<KeyManager>((ref) {
  return KeyManager(
    secureStorage: ref.read(secureStorageProvider),
  );
});

final biometricLockProvider = Provider<BiometricLock>((ref) {
  return BiometricLock();
});

final hashChainServiceProvider = Provider<HashChainService>((ref) {
  return HashChainService(
    keyManager: ref.read(keyManagerProvider),
    transactionRepo: ref.read(transactionRepositoryProvider),
  );
});

final encryptionServiceProvider = Provider<EncryptionService>((ref) {
  return EncryptionService(
    keyManager: ref.read(keyManagerProvider),
  );
});

// æ£€æŸ¥æ˜¯å¦å·²è®¾ç½®å¯†é’¥
final hasKeyPairProvider = FutureProvider<bool>((ref) async {
  final keyManager = ref.read(keyManagerProvider);
  return await keyManager.hasKeyPair();
});

// å“ˆå¸Œé“¾éªŒè¯ç»“æœ
final chainVerificationProvider = FutureProvider.family<ChainVerificationResult, String>(
  (ref, bookId) async {
    final hashChain = ref.read(hashChainServiceProvider);
    return await hashChain.verifyChain(bookId);
  },
);
```

### 5.2 ç¬¬ä¸‰æ–¹åº“ä¾èµ–

```yaml
# pubspec.yaml

dependencies:
  # åŠ å¯†åº“
  cryptography: ^2.7.0
  pointycastle: ^3.9.1  # Ed25519ç­‰ç®—æ³•

  # å®‰å…¨å­˜å‚¨
  flutter_secure_storage: ^9.2.2

  # BIP39åŠ©è®°è¯
  bip39: ^1.0.6

  # ç”Ÿç‰©è¯†åˆ«
  local_auth: ^2.3.0
  local_auth_android: ^1.0.47
  local_auth_ios: ^1.2.1

  # SQLCipher
  sqflite_sqlcipher: ^3.1.0

  # PDFç”Ÿæˆ
  pdf: ^3.11.1
  printing: ^5.13.2

  # çŠ¶æ€ç®¡ç†
  flutter_riverpod: ^2.5.1
```

---

## 6. éªŒæ”¶æ ‡å‡†

### 6.1 åŠŸèƒ½å®Œæ•´æ€§

- âœ… å¯†é’¥ç”ŸæˆæˆåŠŸç‡100%
- âœ… Recovery Kit 24ä¸ªå•è¯æ­£ç¡®æ˜¾ç¤º
- âœ… Recovery Kitå¤‡ä»½éªŒè¯æˆåŠŸç‡100%
- âœ… Recovery Kitæ¢å¤åŠŸèƒ½æ­£å¸¸
- âœ… ç”Ÿç‰©è¯†åˆ«è®¤è¯æˆåŠŸç‡>98%ï¼ˆåœ¨æ”¯æŒè®¾å¤‡ä¸Šï¼‰
- âœ… PINç å¤‡ç”¨æ–¹æ¡ˆå¯ç”¨
- âœ… å“ˆå¸Œé“¾éªŒè¯æ—¶é—´<1ç§’ï¼ˆ1000æ¡è®°å½•ï¼‰
- âœ… ç¯¡æ”¹æ£€æµ‹çµæ•åº¦100%ï¼ˆä¿®æ”¹ä»»ä½•å­—æ®µéƒ½èƒ½æ£€æµ‹ï¼‰
- âœ… å®¡è®¡æŠ¥å‘ŠPDFå¯¼å‡ºæˆåŠŸ
- âœ… éšç§å®£è¨€å¼•å¯¼å®Œæˆç‡>95%
- âœ… æ•°æ®åº“åŠ å¯†/è§£å¯†åŠŸèƒ½æ­£å¸¸
- âœ… å¤‡æ³¨å­—æ®µåŠ å¯†/è§£å¯†åŠŸèƒ½æ­£å¸¸

### 6.2 æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | æµ‹è¯•æ–¹æ³• |
|------|------|---------|
| å¯†é’¥ç”Ÿæˆæ—¶é—´ | <2s | é¦–æ¬¡å¯åŠ¨è®¡æ—¶ |
| ç”Ÿç‰©è¯†åˆ«å“åº”æ—¶é—´ | <1s | ä»è§¦å‘åˆ°ç»“æœ |
| å“ˆå¸Œé“¾éªŒè¯æ—¶é—´ | <1s | 1000æ¡äº¤æ˜“ |
| æ•°æ®åº“è§£å¯†æ—¶é—´ | <500ms | åº”ç”¨å¯åŠ¨è®¡æ—¶ |
| å¤‡æ³¨åŠ å¯†æ—¶é—´ | <10ms | å•æ¡å¤‡æ³¨ |
| PDFå¯¼å‡ºæ—¶é—´ | <5s | 1000æ¡äº¤æ˜“ |

### 6.3 å®‰å…¨æŒ‡æ ‡

- âœ… ç§é’¥æ°¸ä¸ç¦»å¼€å®‰å…¨å­˜å‚¨
- âœ… æ•°æ®åº“å¯†ç æ°¸ä¸æ˜æ–‡å­˜å‚¨
- âœ… å¤‡æ³¨æ˜æ–‡æ°¸ä¸å­˜å‚¨åœ¨æ•°æ®åº“
- âœ… Recovery KitåŠ©è®°è¯æ°¸ä¸å­˜å‚¨ï¼ˆä»…å­˜å‚¨å“ˆå¸Œï¼‰
- âœ… å“ˆå¸Œç®—æ³•ä½¿ç”¨SHA-256
- âœ… åŠ å¯†ç®—æ³•ä½¿ç”¨ChaCha20-Poly1305æˆ–Ed25519
- âœ… å¯†é’¥æ´¾ç”Ÿä½¿ç”¨PBKDF2ï¼ˆè¿­ä»£æ¬¡æ•°â‰¥100,000ï¼‰

---

## 7. æµ‹è¯•ç”¨ä¾‹

### 7.1 å•å…ƒæµ‹è¯•

```dart
// test/core/security/key_manager_test.dart

void main() {
  group('KeyManager', () {
    late KeyManager keyManager;
    late MockSecureStorage mockSecureStorage;

    setUp(() {
      mockSecureStorage = MockSecureStorage();
      keyManager = KeyManager(secureStorage: mockSecureStorage);
    });

    test('should generate valid Ed25519 key pair', () async {
      // When
      final keyPair = await keyManager.generateDeviceKeyPair();

      // Then
      expect(keyPair.publicKey, isNotEmpty);
      expect(keyPair.deviceId, isNotEmpty);
      expect(keyPair.deviceId.length, 16);

      // Verify stored in secure storage
      verify(mockSecureStorage.write(
        key: 'device_private_key',
        value: any,
      ));
    });

    test('should recover key pair from valid mnemonic', () async {
      // Given
      final mnemonic = 'abandon abandon abandon abandon abandon abandon '
                       'abandon abandon abandon abandon abandon about';

      // When
      final keyPair = await keyManager.recoverFromMnemonic(mnemonic);

      // Then
      expect(keyPair.publicKey, isNotEmpty);
      expect(keyPair.deviceId, isNotEmpty);
    });

    test('should throw exception for invalid mnemonic', () async {
      // Given
      final invalidMnemonic = 'invalid mnemonic words';

      // When & Then
      expect(
        () => keyManager.recoverFromMnemonic(invalidMnemonic),
        throwsA(isA<InvalidMnemonicException>()),
      );
    });

    test('should sign and verify data correctly', () async {
      // Given
      await keyManager.generateDeviceKeyPair();
      final data = utf8.encode('test transaction data');

      // When
      final signature = await keyManager.signData(data);
      final publicKey = await keyManager.getPublicKey();
      final isValid = await keyManager.verifySignature(
        data: data,
        signature: signature,
        publicKeyBase64: publicKey!,
      );

      // Then
      expect(isValid, isTrue);
    });

    test('should detect tampered data', () async {
      // Given
      await keyManager.generateDeviceKeyPair();
      final data = utf8.encode('original data');
      final tamperedData = utf8.encode('tampered data');
      final signature = await keyManager.signData(data);
      final publicKey = await keyManager.getPublicKey();

      // When
      final isValid = await keyManager.verifySignature(
        data: tamperedData,
        signature: signature,
        publicKeyBase64: publicKey!,
      );

      // Then
      expect(isValid, isFalse);
    });
  });

  group('RecoveryKitService', () {
    late RecoveryKitService service;

    setUp(() {
      service = RecoveryKitService();
    });

    test('should generate 24-word mnemonic', () async {
      // When
      final mnemonic = await service.generateRecoveryKit();

      // Then
      final words = mnemonic.split(' ');
      expect(words.length, 24);
      expect(bip39.validateMnemonic(mnemonic), isTrue);
    });

    test('should verify correct recovery kit', () async {
      // Given
      final mnemonic = await service.generateRecoveryKit();

      // When
      final isValid = await service.verifyRecoveryKit(mnemonic);

      // Then
      expect(isValid, isTrue);
    });

    test('should reject incorrect recovery kit', () async {
      // Given
      await service.generateRecoveryKit();
      final wrongMnemonic = 'abandon abandon abandon abandon abandon abandon '
                            'abandon abandon abandon abandon abandon about';

      // When
      final isValid = await service.verifyRecoveryKit(wrongMnemonic);

      // Then
      expect(isValid, isFalse);
    });
  });

  group('HashChainService', () {
    late HashChainService hashChain;
    late MockTransactionRepository mockRepo;

    setUp(() {
      mockRepo = MockTransactionRepository();
      hashChain = HashChainService(
        keyManager: KeyManager(secureStorage: MockSecureStorage()),
        transactionRepo: mockRepo,
      );
    });

    test('should calculate consistent hash for same transaction', () async {
      // Given
      final tx = Transaction(
        id: 'tx-001',
        bookId: 'book-001',
        deviceId: 'device-001',
        amount: 1280,
        type: TransactionType.expense,
        categoryId: 'food',
        ledgerType: LedgerType.soul,
        timestamp: DateTime(2026, 2, 3, 14, 30),
        prevHash: 'genesis',
        currentHash: '',
        createdAt: DateTime.now(),
      );

      // When
      final hash1 = await hashChain.calculateHash(tx);
      final hash2 = await hashChain.calculateHash(tx);

      // Then
      expect(hash1, hash2);
    });

    test('should verify valid chain', () async {
      // Given
      final transactions = [
        Transaction(
          id: 'tx-001',
          prevHash: 'genesis',
          currentHash: await hashChain.calculateHash(/* tx-001 */),
          // ... other fields
        ),
        Transaction(
          id: 'tx-002',
          prevHash: 'abc123',  // hash of tx-001
          currentHash: await hashChain.calculateHash(/* tx-002 */),
          // ... other fields
        ),
      ];
      when(mockRepo.getTransactions(any)).thenAnswer((_) async => transactions);

      // When
      final result = await hashChain.verifyChain('book-001');

      // Then
      expect(result.isValid, isTrue);
      expect(result.tamperedTransactions, isEmpty);
    });

    test('should detect tampered transaction', () async {
      // Given
      final validHash = 'abc123def456';
      final tamperedHash = 'xyz987uvw654';  // Wrong hash!

      final transactions = [
        Transaction(
          id: 'tx-001',
          amount: 1280,  // Original
          prevHash: 'genesis',
          currentHash: validHash,
          // ...
        ),
        Transaction(
          id: 'tx-002',
          amount: 500,  // Tampered! (was 5000)
          prevHash: validHash,
          currentHash: tamperedHash,  // Hash doesn't match!
          // ...
        ),
      ];
      when(mockRepo.getTransactions(any)).thenAnswer((_) async => transactions);

      // When
      final result = await hashChain.verifyChain('book-001');

      // Then
      expect(result.isValid, isFalse);
      expect(result.tamperedTransactions.length, 1);
      expect(result.tamperedTransactions.first.id, 'tx-002');
    });
  });
}
```

### 7.2 Widgetæµ‹è¯•

```dart
// test/features/auth/presentation/biometric_lock_screen_test.dart

void main() {
  testWidgets('should authenticate successfully', (tester) async {
    // Given
    final mockBiometricLock = MockBiometricLock();
    when(mockBiometricLock.authenticate(any))
        .thenAnswer((_) async => AuthResult.success());

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          biometricLockProvider.overrideWithValue(mockBiometricLock),
        ],
        child: MaterialApp(home: BiometricLockScreen()),
      ),
    );

    // When
    await tester.pumpAndSettle();

    // Then
    verify(mockBiometricLock.authenticate(
      reason: 'Home Pocketã‚’é–‹ãã«ã¯èªè¨¼ãŒå¿…è¦ã§ã™',
    ));
  });

  testWidgets('should show PIN dialog after failed attempts', (tester) async {
    // Given
    final mockBiometricLock = MockBiometricLock();
    when(mockBiometricLock.authenticate(any))
        .thenAnswer((_) async => AuthResult.tooManyAttempts());

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          biometricLockProvider.overrideWithValue(mockBiometricLock),
        ],
        child: MaterialApp(home: BiometricLockScreen()),
      ),
    );

    // When
    await tester.pumpAndSettle();

    // Then
    expect(find.text('PINã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›'), findsOneWidget);
  });
}
```

### 7.3 é›†æˆæµ‹è¯•

```dart
// integration_test/security_flow_test.dart

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('complete security setup flow', (tester) async {
    // Given - first launch
    await tester.pumpWidget(MyApp());
    await tester.pumpAndSettle();

    // Then - should show privacy onboarding
    expect(find.text('ã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã¯\nã‚ãªãŸã ã‘ã®ã‚‚ã®'), findsOneWidget);

    // When - navigate through onboarding
    await tester.tap(find.text('æ¬¡ã¸ â†’'));
    await tester.pumpAndSettle();

    expect(find.text('æ”¹ã–ã‚“ã§ããªã„è¨˜éŒ²'), findsOneWidget);

    await tester.tap(find.text('æ¬¡ã¸ â†’'));
    await tester.pumpAndSettle();

    expect(find.text('é€æ˜ã§ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹'), findsOneWidget);

    // When - complete onboarding
    await tester.tap(find.text('å§‹ã‚ã‚‹'));
    await tester.pumpAndSettle();

    // Then - should show recovery kit backup screen
    expect(find.text('Recovery Kit å‚™ä»½'), findsOneWidget);
    expect(find.textContaining('1.'), findsWidgets);  // Mnemonic words

    // When - export to PDF
    await tester.tap(find.text('ä¿å­˜ç‚ºPDF'));
    await tester.pumpAndSettle();

    // TODO: verify PDF file created

    // When - check all confirmations
    await tester.tap(find.byType(Checkbox).at(0));
    await tester.tap(find.byType(Checkbox).at(1));
    await tester.tap(find.byType(Checkbox).at(2));
    await tester.pumpAndSettle();

    // When - proceed to verification
    await tester.tap(find.text('ä¸‹ä¸€æ­¥'));
    await tester.pumpAndSettle();

    // Then - should show verification screen
    expect(find.text('é©—è­‰ Recovery Kit'), findsOneWidget);

    // TODO: input correct words and verify
  });

  testWidgets('hash chain verification', (tester) async {
    // Given - app with transactions
    await tester.pumpWidget(MyApp());
    await tester.pumpAndSettle();

    // Navigate to settings
    await tester.tap(find.byIcon(Icons.settings));
    await tester.pumpAndSettle();

    // When - tap on hash chain audit
    await tester.tap(find.text('é©—è­‰å®Œæ•´æ€§'));
    await tester.pumpAndSettle();

    // Then - should show verification result
    expect(find.text('âœ… å®Œæ•´'), findsOneWidget);

    // When - export audit report
    await tester.tap(find.text('å°å‡ºå¯©è¨ˆå ±å‘ŠPDF'));
    await tester.pumpAndSettle();

    // TODO: verify PDF file created
  });
}
```

---

## 8. å¼€å‘é‡Œç¨‹ç¢‘

### 8.1 è¯¦ç»†ä»»åŠ¡æ‹†è§£ï¼ˆ10å¤©ï¼‰

| Day | ä»»åŠ¡ | äº§å‡º | é£é™© |
|-----|------|------|------|
| **Day 1** | å¯†é’¥ç®¡ç†åŸºç¡€ | - KeyManagerå®ç°<br>- Ed25519å¯†é’¥ç”Ÿæˆ<br>- å®‰å…¨å­˜å‚¨é›†æˆ | ä¸­ï¼ˆåŠ å¯†åº“å…¼å®¹æ€§ï¼‰|
| **Day 2** | Recovery Kit | - BIP39åŠ©è®°è¯ç”Ÿæˆ<br>- éªŒè¯æœºåˆ¶<br>- PDFå¯¼å‡º | ä½ |
| **Day 3** | ç”Ÿç‰©è¯†åˆ«é” | - BiometricLockå®ç°<br>- local_authé›†æˆ<br>- PINå¤‡ç”¨æ–¹æ¡ˆ | ä¸­ï¼ˆå¹³å°å·®å¼‚ï¼‰|
| **Day 4** | æ•°æ®åº“åŠ å¯† | - SQLCipheré›†æˆ<br>- å¯†é’¥æ´¾ç”Ÿ<br>- æ€§èƒ½æµ‹è¯• | é«˜ï¼ˆæ€§èƒ½é—®é¢˜ï¼‰|
| **Day 5** | å¤‡æ³¨å­—æ®µåŠ å¯† | - EncryptionService<br>- ChaCha20-Poly1305<br>- åŠ è§£å¯†æµ‹è¯• | ä½ |
| **Day 6** | å“ˆå¸Œé“¾åŸºç¡€ | - HashChainService<br>- å“ˆå¸Œè®¡ç®—<br>- é“¾å¼éªŒè¯ | ä¸­ï¼ˆç®—æ³•æ­£ç¡®æ€§ï¼‰|
| **Day 7** | å“ˆå¸Œé“¾UI | - å®¡è®¡æŸ¥çœ‹å™¨<br>- PDFæŠ¥å‘Šç”Ÿæˆ<br>- ç¯¡æ”¹æ£€æµ‹å±•ç¤º | ä½ |
| **Day 8** | éšç§å¼•å¯¼UI | - ä¸‰é¡µå¼•å¯¼é¡µé¢<br>- åŠ¨ç”»æ•ˆæœ<br>- æµç¨‹é›†æˆ | ä½ |
| **Day 9** | é›†æˆæµ‹è¯• | - ç«¯åˆ°ç«¯æµ‹è¯•<br>- å®‰å…¨å®¡è®¡<br>- æ€§èƒ½ä¼˜åŒ– | é«˜ï¼ˆé›†æˆé—®é¢˜ï¼‰|
| **Day 10** | æ–‡æ¡£ä¸ä¼˜åŒ– | - APIæ–‡æ¡£<br>- ç”¨æˆ·æ‰‹å†Œ<br>- Bugä¿®å¤ | ä½ |

### 8.2 å…³é”®è·¯å¾„è¯†åˆ«

```
Day 1 (å¯†é’¥ç®¡ç†)
    â†“
Day 2 (Recovery Kit) â”€â”€â”
                       â”œâ”€â”€â–º Day 4 (æ•°æ®åº“åŠ å¯†)
Day 3 (ç”Ÿç‰©è¯†åˆ«) â”€â”€â”€â”€â”€â”€â”˜         â†“
                               Day 5 (å¤‡æ³¨åŠ å¯†)
                                 â†“
Day 6 (å“ˆå¸Œé“¾åŸºç¡€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â†“                            â†“
Day 7 (å“ˆå¸Œé“¾UI)                 â”‚
    â†“                            â†“
Day 8 (éšç§å¼•å¯¼) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â†“                            â†“
Day 9-10 (æµ‹è¯•ä¸ä¼˜åŒ–)
```

**å…³é”®è·¯å¾„:** Day 1 â†’ Day 4 â†’ Day 5 â†’ Day 9
**æœ€å¤§é£é™©:** SQLCipheræ€§èƒ½é—®é¢˜å¯èƒ½å¯¼è‡´åº”ç”¨å¯åŠ¨ç¼“æ…¢

### 8.3 é£é™©ä¸ç¼“è§£æªæ–½

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|------|---------|
| SQLCipheræ€§èƒ½å·® | ä¸­ | é«˜ | æå‰æ€§èƒ½æµ‹è¯•,å‡†å¤‡é™çº§æ–¹æ¡ˆï¼ˆä»…åŠ å¯†æ•æ„Ÿå­—æ®µï¼‰|
| å¹³å°ç”Ÿç‰©è¯†åˆ«å·®å¼‚ | ä¸­ | ä¸­ | å®Œå–„çš„PINå¤‡ç”¨æ–¹æ¡ˆ,å……åˆ†æµ‹è¯• |
| å¯†é’¥æ¢å¤å¤±è´¥ç‡é«˜ | ä½ | é«˜ | å¤šé‡éªŒè¯æœºåˆ¶,æä¾›ç¤¾äº¤æ¢å¤é€‰é¡¹ï¼ˆV1.0ï¼‰|
| å“ˆå¸Œé“¾éªŒè¯æ…¢ | ä½ | ä¸­ | å¢é‡éªŒè¯,åå°å¼‚æ­¥æ‰§è¡Œ |

---

## 9. é™„å½•

### 9.1 ç›¸å…³æ–‡æ¡£é“¾æ¥

- [PRD_Module_BasicAccounting.md](/Users/xinz/Development/ThinkCenter/claudedocs/PRD_Module_BasicAccounting.md)
- [research_home_pocket_feasibility_strategy_20260202_CN.md](/Users/xinz/Development/ThinkCenter/claudedocs/research_home_pocket_feasibility_strategy_20260202_CN.md)

### 9.2 æŠ€æœ¯å‚è€ƒèµ„æ–™

**åŠ å¯†åº“:**
- [cryptography (Dart)](https://pub.dev/packages/cryptography)
- [Ed25519ç­¾åç®—æ³•](https://ed25519.cr.yp.to/)
- [ChaCha20-Poly1305è§„èŒƒ](https://tools.ietf.org/html/rfc8439)

**SQLCipher:**
- [SQLCipheræ–‡æ¡£](https://www.zetetic.net/sqlcipher/documentation/)
- [sqflite_sqlcipher](https://pub.dev/packages/sqflite_sqlcipher)

**BIP39:**
- [BIP39è§„èŒƒ](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
- [bip39 (Dart)](https://pub.dev/packages/bip39)

**ç”Ÿç‰©è¯†åˆ«:**
- [local_auth](https://pub.dev/packages/local_auth)
- [iOS Local Authentication](https://developer.apple.com/documentation/localauthentication)
- [Android BiometricPrompt](https://developer.android.com/training/sign-in/biometric-auth)

### 9.3 è®¾è®¡å†³ç­–è®°å½•

**å†³ç­–001: ä¸ºä»€ä¹ˆé€‰æ‹©Ed25519è€ŒéRSA?**
- æ—¥æœŸ: 2026-02-03
- åŸå› : æ€§èƒ½æ›´å¥½ï¼ˆç­¾åéªŒè¯å¿«10å€ï¼‰,å¯†é’¥æ›´çŸ­ï¼ˆ32å­—èŠ‚å…¬é’¥ vs 2048ä½RSAï¼‰
- å‚è€ƒ: [Ed25519æ€§èƒ½å¯¹æ¯”](https://ed25519.cr.yp.to/)

**å†³ç­–002: ä¸ºä»€ä¹ˆä¸ä½¿ç”¨äº‘å¤‡ä»½Recovery Kit?**
- æ—¥æœŸ: 2026-02-03
- åŸå› : éšç§æ‰¿è¯ºï¼ˆä¸ä¸Šä¼ æ•°æ®åˆ°æœåŠ¡å™¨ï¼‰,ç”¨æˆ·å¯é€‰æ‹©è‡ªå·±çš„å¤‡ä»½æ–¹å¼ï¼ˆPDF/æ‰“å°ï¼‰
- æ›¿ä»£æ–¹æ¡ˆ: V1.0æä¾›åŠ å¯†äº‘å¤‡ä»½é€‰é¡¹ï¼ˆéœ€ç”¨æˆ·é¢å¤–å¯†ç ï¼‰

**å†³ç­–003: ä¸ºä»€ä¹ˆä½¿ç”¨BIP39è€Œéè‡ªå®šä¹‰åŠ©è®°è¯?**
- æ—¥æœŸ: 2026-02-03
- åŸå› : è¡Œä¸šæ ‡å‡†,ç”¨æˆ·ç†Ÿæ‚‰åº¦é«˜ï¼ˆåŠ å¯†è´§å¸ç”¨æˆ·ï¼‰,æ ¡éªŒå’Œé˜²é”™
- å½±å“: éœ€è¦ä¾èµ–bip39åº“

**å†³ç­–004: ä¸ºä»€ä¹ˆå“ˆå¸Œé“¾ä¸ä½¿ç”¨æ•°å­—ç­¾å?**
- æ—¥æœŸ: 2026-02-03
- åŸå› : MVPé˜¶æ®µç®€åŒ–å®ç°,SHA-256å·²è¶³å¤Ÿé˜²ç¯¡æ”¹
- V1.0ä¼˜åŒ–: æ·»åŠ Ed25519ç­¾åå¢å¼ºå®‰å…¨æ€§

---

**æ–‡æ¡£çŠ¶æ€:** å®Œæˆ
**å®¡æ ¸çŠ¶æ€:** å¾…è¯„å®¡
**éœ€è¦è¯„å®¡:** äº§å“ç»ç†ã€å®‰å…¨å·¥ç¨‹å¸ˆã€æŠ€æœ¯è´Ÿè´£äºº

**å˜æ›´æ—¥å¿—:**
- 2026-02-03: åˆç‰ˆå®Œæˆï¼ˆåŸºäºæ¡†æ¶æ–‡æ¡£å’Œå¯è¡Œæ€§ç ”ç©¶ï¼‰
