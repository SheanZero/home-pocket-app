# PRD - OCRæ‰«ææ¨¡å—

**æ¨¡å—ID:** MOD-005
**æ¨¡å—åç§°:** OCRæ‰«ææ¨¡å—
**ç‰ˆæœ¬:** 1.0
**åˆ›å»ºæ—¥æœŸ:** 2026å¹´2æœˆ3æ—¥
**ä¼˜å…ˆçº§:** P1ï¼ˆå¼ºçƒˆå»ºè®®ï¼‰
**é¢„ä¼°å·¥æ—¶:** 7å¤©

---

## 1. æ¨¡å—æ¦‚è¿°

### 1.1 åŠŸèƒ½å®šä¹‰

OCRæ‰«ææ¨¡å—é€šè¿‡ç›¸æœºæ‰«æçº¸è´¨æ”¶æ®,è‡ªåŠ¨è¯†åˆ«é‡‘é¢ã€æ—¥æœŸã€å•†å®¶ä¿¡æ¯å¹¶åˆ›å»ºäº¤æ˜“è®°å½•ã€‚åŒ…æ‹¬:

- **æ”¶æ®æ‰«æï¼ˆA10ï¼‰:** æ‹ç…§æˆ–ä»ç›¸å†Œé€‰æ‹©
- **OCRè¯†åˆ«:** é‡‘é¢ã€æ—¥æœŸã€å•†å®¶åç§°è‡ªåŠ¨æå–
- **å•†å®¶è‡ªåŠ¨åˆ†ç±»ï¼ˆA11ï¼‰:** æ ¹æ®å•†å®¶åŒ¹é…åˆ†ç±»å’Œè´¦æˆ·ç±»å‹
- **ç”¨æˆ·ç¡®è®¤:** å¯ç¼–è¾‘è¯†åˆ«ç»“æœ
- **ç…§ç‰‡åŠ å¯†å­˜å‚¨:** æ”¶æ®ç…§ç‰‡ç«¯åˆ°ç«¯åŠ å¯†ä¿å­˜

**æ ¸å¿ƒä»·å€¼ä¸»å¼ :**
å°†çº¸è´¨æ”¶æ®æ•°å­—åŒ–,èŠ‚çœæ‰‹åŠ¨è¾“å…¥æ—¶é—´ã€‚é€šè¿‡å•†å®¶æ•°æ®åº“è‡ªåŠ¨åˆ†ç±»,è¿›ä¸€æ­¥æå‡è®°è´¦æ•ˆç‡ã€‚

**æ³¨æ„:** æ ¹æ®å¯è¡Œæ€§ç ”ç©¶,å‡†ç¡®ç‡ç›®æ ‡è°ƒæ•´ä¸º90%ï¼ˆä¸æ˜¯95%ï¼‰,å› ä¸ºML Kitåœ¨æ‰‹å†™/è¤ªè‰²æ”¶æ®ä¸Šå‡†ç¡®ç‡æœ‰é™ã€‚

### 1.2 ç”¨æˆ·åœºæ™¯ä¸ç—›ç‚¹

**ç”¨æˆ·ç”»åƒ:**
- ä½è—¤å¤ªéƒï¼ˆ35å²,ç»å¸¸å¤–é£Ÿï¼‰
- é’±åŒ…é‡Œç§¯ç´¯äº†å¤§é‡çº¸è´¨æ”¶æ®
- æ¯å‘¨æœ«æ‰æœ‰æ—¶é—´æ•´ç†,ç»å¸¸å¿˜è®°å½“æ—¶ä¹°äº†ä»€ä¹ˆ

**ç—›ç‚¹:**
1. **æ‰‹åŠ¨è¾“å…¥ç¹ç:** ä¸€å¼ æ”¶æ®è¦è¾“å…¥é‡‘é¢ã€æ—¥æœŸã€å•†å®¶,å®¹æ˜“å‡ºé”™
2. **æ”¶æ®ä¸¢å¤±:** çº¸è´¨æ”¶æ®å®¹æ˜“è¤ªè‰²ã€ä¸¢å¤±,äº‹åæ— æ³•æŸ¥è¯
3. **åˆ†ç±»å›°éš¾:** ä¸ç¡®å®šè¿™ç¬”æ¶ˆè´¹åº”è¯¥å½’ä¸ºå“ªä¸ªåˆ†ç±»

**Home Pocketè§£å†³æ–¹æ¡ˆ:**
- ä¸€é”®æ‰«æ,2ç§’å†…å®Œæˆä¿¡æ¯æå–
- æ”¶æ®ç…§ç‰‡åŠ å¯†ä¿å­˜,æ°¸ä¸ä¸¢å¤±
- å•†å®¶æ•°æ®åº“è‡ªåŠ¨åŒ¹é…åˆ†ç±»å’Œè´¦æˆ·ç±»å‹

### 1.3 ä¸å…¶ä»–æ¨¡å—çš„ä¾èµ–å…³ç³»

**å‰ç½®ä¾èµ–:**
- MOD-001 åŸºç¡€è®°è´¦ï¼ˆéœ€è¦äº¤æ˜“åˆ›å»ºæµç¨‹ï¼‰
- MOD-003 åŒè½¨è´¦æœ¬ï¼ˆéœ€è¦å•†å®¶æ•°æ®åº“ï¼‰
- MOD-006 å®‰å…¨ä¸éšç§ï¼ˆéœ€è¦ç…§ç‰‡åŠ å¯†ï¼‰

**è¢«ä¾èµ–:**
- MOD-009 è¶£å‘³åŠŸèƒ½ï¼ˆå°ç¥¨å åœï¼‰

---

## 2. è¯¦ç»†åŠŸèƒ½è§„æ ¼

### 2.1 A10: æ”¶æ®æ‰«æ

#### 2.1.1 æŠ€æœ¯é€‰å‹

**iOS:**
- æ¡†æ¶: Vision Framework
- API: `VNRecognizeTextRequest`
- è¯­è¨€: æ—¥è¯­ï¼ˆjaï¼‰+ è‹±è¯­ï¼ˆenï¼‰
- è¯†åˆ«çº§åˆ«: `accurate`ï¼ˆé«˜ç²¾åº¦æ¨¡å¼ï¼‰

**Android:**
- æ¡†æ¶: ML Kit Text Recognition v2
- API: `TextRecognizer`
- è¯­è¨€: æ—¥è¯­ + è‹±è¯­
- æ¨¡å‹: è®¾å¤‡ç«¯æ¨¡å‹ï¼ˆæ— éœ€ç½‘ç»œï¼‰

**ä¸ºä»€ä¹ˆä¸ç”¨ç¬¬ä¸‰æ–¹äº‘OCRï¼ˆå¦‚Google Cloud Visionï¼‰?**
- éšç§æ‰¿è¯º:æ•°æ®ä¸ä¸Šä¼ æœåŠ¡å™¨
- æˆæœ¬è€ƒè™‘:é¿å…APIè°ƒç”¨è´¹ç”¨
- ç¦»çº¿å¯ç”¨:æ— ç½‘ç»œä¹Ÿèƒ½ä½¿ç”¨

#### 2.1.2 è¯†åˆ«ç›®æ ‡

| å­—æ®µ | æ­£åˆ™è¡¨è¾¾å¼ | å‡†ç¡®ç‡ç›®æ ‡ |
|------|-----------|----------|
| é‡‘é¢ | `Â¥?\s*\d{1,3}(,\d{3})*\s*å††?` | >90% |
| æ—¥æœŸ | `\d{4}[å¹´/.-]\d{1,2}[æœˆ/.-]\d{1,2}æ—¥?` | >85% |
| å•†å®¶ | OCRç»“æœç¬¬ä¸€è¡Œï¼ˆå¯å‘å¼ï¼‰| >80% |
| åˆè®¡ | å…³é”®è¯åŒ¹é… `åˆè¨ˆ\|åˆè®¡\|TOTAL\|å°è¨ˆ` | >90% |

**é™ä½ç›®æ ‡çš„åŸå› ï¼ˆæ ¹æ®å¯è¡Œæ€§ç ”ç©¶ï¼‰:**
- ML Kitåœ¨æ‰“å°æ¸…æ™°çš„æ”¶æ®ä¸Šè¡¨ç°è‰¯å¥½ï¼ˆ>95%ï¼‰
- ä½†åœ¨æ‰‹å†™ã€è¤ªè‰²ã€è¤¶çš±çš„æ”¶æ®ä¸Šå‡†ç¡®ç‡ä¸‹é™è‡³80-85%
- MVPé˜¶æ®µæ¥å—è¾ƒä½å‡†ç¡®ç‡,æä¾›æ‰‹åŠ¨ä¿®æ­£æµç¨‹

#### 2.1.3 è¯†åˆ«æµç¨‹

```dart
// lib/features/ocr/domain/use_cases/scan_receipt.dart

import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'package:image_picker/image_picker.dart';
import 'package:image/image.dart' as img;

class ScanReceiptUseCase {
  final TextRecognizer _textRecognizer = TextRecognizer(script: TextRecognitionScript.japanese);
  final MerchantDatabase _merchantDB;
  final EncryptionService _encryption;

  Future<ReceiptData> execute({
    required ImageSource source,  // camera or gallery
  }) async {
    // 1. è·å–å›¾åƒ
    final XFile? image = await ImagePicker().pickImage(source: source);
    if (image == null) {
      throw CancelledException('ç”¨æˆ·å–æ¶ˆé€‰æ‹©');
    }

    // 2. å›¾åƒé¢„å¤„ç†ï¼ˆæé«˜è¯†åˆ«å‡†ç¡®ç‡ï¼‰
    final processedImage = await _preprocessImage(image);

    // 3. OCRè¯†åˆ«
    final inputImage = InputImage.fromFilePath(processedImage.path);
    final RecognizedText recognizedText = await _textRecognizer.processImage(inputImage);

    // 4. ç»“æ„åŒ–æå–
    final extractedData = _extractData(recognizedText);

    // 5. å•†å®¶è‡ªåŠ¨åˆ†ç±»
    final category = await _classifyMerchant(extractedData.merchant);

    // 6. åŠ å¯†å­˜å‚¨ç…§ç‰‡
    final photoHash = await _encryptAndStorePhoto(image);

    return ReceiptData(
      amount: extractedData.amount,
      date: extractedData.date,
      merchant: extractedData.merchant,
      category: category,
      photoHash: photoHash,
      rawText: recognizedText.text,
      confidence: extractedData.confidence,
    );
  }

  /// å›¾åƒé¢„å¤„ç†ï¼ˆå»å™ªã€äºŒå€¼åŒ–ã€æ—‹è½¬æ ¡æ­£ï¼‰
  Future<XFile> _preprocessImage(XFile image) async {
    final bytes = await image.readAsBytes();
    img.Image? decodedImage = img.decodeImage(bytes);

    if (decodedImage == null) {
      throw ImageProcessingException('å›¾åƒè§£ç å¤±è´¥');
    }

    // 1. ç°åº¦åŒ–
    decodedImage = img.grayscale(decodedImage);

    // 2. å¯¹æ¯”åº¦å¢å¼º
    decodedImage = img.adjustColor(decodedImage, contrast: 1.5);

    // 3. äºŒå€¼åŒ–ï¼ˆæé«˜æ–‡å­—æ¸…æ™°åº¦ï¼‰
    decodedImage = _binarize(decodedImage);

    // 4. æ—‹è½¬æ ¡æ­£ï¼ˆå¦‚æœéœ€è¦ï¼‰
    decodedImage = await _correctRotation(decodedImage);

    // 5. ä¿å­˜å¤„ç†åçš„å›¾åƒ
    final processedBytes = img.encodePng(decodedImage);
    final tempDir = await getTemporaryDirectory();
    final processedFile = File('${tempDir.path}/processed_${DateTime.now().millisecondsSinceEpoch}.png');
    await processedFile.writeAsBytes(processedBytes);

    return XFile(processedFile.path);
  }

  img.Image _binarize(img.Image image) {
    // OtsuäºŒå€¼åŒ–ç®—æ³•
    final threshold = _calculateOtsuThreshold(image);

    for (var y = 0; y < image.height; y++) {
      for (var x = 0; x < image.width; x++) {
        final pixel = image.getPixel(x, y);
        final gray = img.getLuminance(pixel);
        final newPixel = gray > threshold ? img.ColorRgba8(255, 255, 255, 255) : img.ColorRgba8(0, 0, 0, 255);
        image.setPixel(x, y, newPixel);
      }
    }

    return image;
  }

  int _calculateOtsuThreshold(img.Image image) {
    // ç®€åŒ–ç‰ˆOtsuç®—æ³•ï¼ˆå®Œæ•´å®ç°ç•¥ï¼‰
    return 128;  // MVPé˜¶æ®µä½¿ç”¨å›ºå®šé˜ˆå€¼
  }

  /// ç»“æ„åŒ–æ•°æ®æå–
  ExtractedData _extractData(RecognizedText recognizedText) {
    final text = recognizedText.text;
    final lines = text.split('\n');

    // 1. æå–é‡‘é¢
    final amount = _extractAmount(text);

    // 2. æå–æ—¥æœŸ
    final date = _extractDate(text);

    // 3. æå–å•†å®¶åç§°ï¼ˆå¯å‘å¼ï¼šç¬¬ä¸€è¡Œéæ—¥æœŸæ–‡æœ¬ï¼‰
    final merchant = _extractMerchant(lines);

    return ExtractedData(
      amount: amount,
      date: date,
      merchant: merchant,
      confidence: _calculateConfidence(amount, date, merchant),
    );
  }

  int? _extractAmount(String text) {
    // æ­£åˆ™åŒ¹é…ï¼šÂ¥1,280 æˆ– 1280å†† æˆ– 1280
    final patterns = [
      RegExp(r'[Â¥ï¿¥]\s*(\d{1,3}(?:,\d{3})*)', multiLine: true),
      RegExp(r'(\d{1,3}(?:,\d{3})*)\s*å††', multiLine: true),
      RegExp(r'åˆè¨ˆ.*?(\d{1,3}(?:,\d{3})*)', multiLine: true),
      RegExp(r'TOTAL.*?(\d{1,3}(?:,\d{3})*)', multiLine: true, caseSensitive: false),
    ];

    for (final pattern in patterns) {
      final match = pattern.firstMatch(text);
      if (match != null && match.groupCount > 0) {
        final amountStr = match.group(1)!.replaceAll(',', '');
        return int.tryParse(amountStr);
      }
    }

    // å›é€€ï¼šæŸ¥æ‰¾æœ€å¤§çš„æ•°å­—ï¼ˆå¯èƒ½æ˜¯åˆè®¡é‡‘é¢ï¼‰
    final numbers = RegExp(r'\d{1,3}(?:,\d{3})*').allMatches(text);
    final amounts = numbers
        .map((m) => int.tryParse(m.group(0)!.replaceAll(',', '')))
        .where((a) => a != null && a > 0)
        .toList();

    if (amounts.isNotEmpty) {
      amounts.sort((a, b) => b!.compareTo(a!));
      return amounts.first;
    }

    return null;
  }

  DateTime? _extractDate(String text) {
    // æ­£åˆ™åŒ¹é…æ—¥æœŸæ ¼å¼
    final patterns = [
      RegExp(r'(\d{4})[å¹´/.-](\d{1,2})[æœˆ/.-](\d{1,2})æ—¥?'),
      RegExp(r'(\d{4})[/.-](\d{1,2})[/.-](\d{1,2})'),
      RegExp(r'(\d{2})[/.-](\d{1,2})[/.-](\d{1,2})'),  // YY/MM/DD
    ];

    for (final pattern in patterns) {
      final match = pattern.firstMatch(text);
      if (match != null) {
        try {
          var year = int.parse(match.group(1)!);
          final month = int.parse(match.group(2)!);
          final day = int.parse(match.group(3)!);

          // å¦‚æœæ˜¯ä¸¤ä½å¹´ä»½,è¡¥å…¨ä¸ºå®Œæ•´å¹´ä»½
          if (year < 100) {
            year += 2000;
          }

          return DateTime(year, month, day);
        } catch (e) {
          continue;
        }
      }
    }

    // å›é€€ï¼šä½¿ç”¨å½“å‰æ—¥æœŸ
    return DateTime.now();
  }

  String? _extractMerchant(List<String> lines) {
    // å¯å‘å¼ï¼šç¬¬ä¸€è¡Œéç©ºã€éæ—¥æœŸã€éé‡‘é¢çš„æ–‡æœ¬
    for (final line in lines) {
      final trimmed = line.trim();

      // è·³è¿‡ç©ºè¡Œ
      if (trimmed.isEmpty) continue;

      // è·³è¿‡çº¯æ•°å­—æˆ–æ—¥æœŸ
      if (RegExp(r'^\d+$').hasMatch(trimmed)) continue;
      if (RegExp(r'\d{4}[å¹´/.-]').hasMatch(trimmed)) continue;

      // è·³è¿‡é‡‘é¢è¡Œ
      if (trimmed.contains('Â¥') || trimmed.contains('å††') || trimmed.contains('åˆè¨ˆ')) continue;

      // å¯èƒ½æ˜¯å•†å®¶åç§°
      return trimmed;
    }

    return null;
  }

  double _calculateConfidence(int? amount, DateTime? date, String? merchant) {
    var confidence = 0.0;

    if (amount != null && amount > 0) confidence += 0.4;
    if (date != null) confidence += 0.3;
    if (merchant != null && merchant.isNotEmpty) confidence += 0.3;

    return confidence;
  }

  /// å•†å®¶è‡ªåŠ¨åˆ†ç±»
  Future<CategoryMatch?> _classifyMerchant(String? merchant) async {
    if (merchant == null || merchant.isEmpty) {
      return null;
    }

    return _merchantDB.findMerchant(merchant);
  }

  /// åŠ å¯†å­˜å‚¨ç…§ç‰‡
  Future<String> _encryptAndStorePhoto(XFile image) async {
    // 1. è¯»å–å›¾åƒå­—èŠ‚
    final bytes = await image.readAsBytes();

    // 2. åŠ å¯†
    final encryptedBytes = await _encryption.encryptBytes(bytes);

    // 3. è®¡ç®—å“ˆå¸Œï¼ˆä½œä¸ºæ–‡ä»¶åï¼‰
    final hash = sha256.convert(bytes);
    final photoHash = base64Encode(hash.bytes);

    // 4. ä¿å­˜åˆ°åº”ç”¨ç›®å½•
    final appDir = await getApplicationDocumentsDirectory();
    final photoFile = File('${appDir.path}/receipts/$photoHash.enc');
    await photoFile.create(recursive: true);
    await photoFile.writeAsBytes(encryptedBytes);

    return photoHash;
  }

  @override
  void dispose() {
    _textRecognizer.close();
  }
}

class ReceiptData {
  final int? amount;
  final DateTime? date;
  final String? merchant;
  final CategoryMatch? category;
  final String photoHash;
  final String rawText;
  final double confidence;

  ReceiptData({
    required this.amount,
    required this.date,
    required this.merchant,
    required this.category,
    required this.photoHash,
    required this.rawText,
    required this.confidence,
  });
}

class ExtractedData {
  final int? amount;
  final DateTime? date;
  final String? merchant;
  final double confidence;

  ExtractedData({
    required this.amount,
    required this.date,
    required this.merchant,
    required this.confidence,
  });
}
```

---

### 2.2 A11: å•†å®¶è‡ªåŠ¨åˆ†ç±»

**å•†å®¶æ•°æ®åº“ï¼ˆ500+æ—¥æœ¬å•†å®¶ï¼‰:**

```dart
// lib/features/ocr/data/merchant_database.dart

class MerchantDatabase {
  /// æ—¥æœ¬å¸¸è§å•†å®¶æ•°æ®åº“
  static const Map<String, MerchantInfo> merchants = {
    // ä¾¿åˆ©åº—
    'ã‚»ãƒ–ãƒ³ã‚¤ãƒ¬ãƒ–ãƒ³': MerchantInfo(
      category: 'food_groceries',
      ledgerType: LedgerType.survival,
      confidence: 0.9,
      aliases: ['ã‚»ãƒ–ãƒ³', '7-11', '7-ELEVEN'],
    ),
    'ãƒ•ã‚¡ãƒŸãƒªãƒ¼ãƒãƒ¼ãƒˆ': MerchantInfo(
      category: 'food_groceries',
      ledgerType: LedgerType.survival,
      confidence: 0.9,
      aliases: ['ãƒ•ã‚¡ãƒŸãƒ', 'FamilyMart'],
    ),
    'ãƒ­ãƒ¼ã‚½ãƒ³': MerchantInfo(
      category: 'food_groceries',
      ledgerType: LedgerType.survival,
      confidence: 0.9,
      aliases: ['LAWSON'],
    ),

    // è¶…å¸‚
    'ã‚¤ã‚ªãƒ³': MerchantInfo(
      category: 'food_groceries',
      ledgerType: LedgerType.survival,
      confidence: 0.85,
      aliases: ['AEON'],
    ),
    'ã‚¤ãƒˆãƒ¼ãƒ¨ãƒ¼ã‚«ãƒ‰ãƒ¼': MerchantInfo(
      category: 'food_groceries',
      ledgerType: LedgerType.survival,
      confidence: 0.85,
      aliases: ['ITO YOKADO'],
    ),

    // é¤é¥®
    'å‰é‡å®¶': MerchantInfo(
      category: 'food_restaurant',
      ledgerType: LedgerType.soul,
      confidence: 0.95,
      aliases: ['YOSHINOYA'],
    ),
    'ãƒã‚¯ãƒ‰ãƒŠãƒ«ãƒ‰': MerchantInfo(
      category: 'food_restaurant',
      ledgerType: LedgerType.soul,
      confidence: 0.95,
      aliases: ["McDonald's", 'ãƒãƒƒã‚¯'],
    ),
    'ã‚¹ã‚¿ãƒ¼ãƒãƒƒã‚¯ã‚¹': MerchantInfo(
      category: 'food_restaurant',
      ledgerType: LedgerType.soul,
      confidence: 0.9,
      aliases: ['STARBUCKS', 'ã‚¹ã‚¿ãƒ'],
    ),

    // äº¤é€š
    'JRæ±æ—¥æœ¬': MerchantInfo(
      category: 'transport_commute',
      ledgerType: LedgerType.survival,
      confidence: 0.95,
      aliases: ['JR EAST'],
    ),
    'æ±äº¬ãƒ¡ãƒˆãƒ­': MerchantInfo(
      category: 'transport_commute',
      ledgerType: LedgerType.survival,
      confidence: 0.95,
      aliases: ['TOKYO METRO'],
    ),

    // è´­ç‰©
    'ãƒ¨ãƒ‰ãƒã‚·ã‚«ãƒ¡ãƒ©': MerchantInfo(
      category: 'shopping_electronics',
      ledgerType: LedgerType.soul,
      confidence: 0.8,
      aliases: ['Yodobashi'],
    ),
    'ãƒ¦ãƒ‹ã‚¯ãƒ­': MerchantInfo(
      category: 'shopping_fashion',
      ledgerType: LedgerType.soul,
      confidence: 0.85,
      aliases: ['UNIQLO'],
    ),

    // åŒ»ç–—
    'ãƒãƒ„ãƒ¢ãƒˆã‚­ãƒ¨ã‚·': MerchantInfo(
      category: 'medical',
      ledgerType: LedgerType.survival,
      confidence: 0.85,
      aliases: ['Matsumoto Kiyoshi'],
    ),

    // ... çœç•¥å…¶ä»–å•†å®¶ ...
  };

  /// æŸ¥æ‰¾å•†å®¶
  CategoryMatch? findMerchant(String merchantName) {
    // 1. ç²¾ç¡®åŒ¹é…
    if (merchants.containsKey(merchantName)) {
      final info = merchants[merchantName]!;
      return CategoryMatch(info.category, info.confidence);
    }

    // 2. åˆ«ååŒ¹é…
    for (final entry in merchants.entries) {
      if (entry.value.aliases.contains(merchantName)) {
        return CategoryMatch(entry.value.category, entry.value.confidence);
      }
    }

    // 3. æ¨¡ç³ŠåŒ¹é…ï¼ˆåŒ…å«å…³ç³»ï¼‰
    for (final entry in merchants.entries) {
      if (merchantName.contains(entry.key) || entry.key.contains(merchantName)) {
        return CategoryMatch(entry.value.category, entry.value.confidence * 0.8);
      }

      // æ£€æŸ¥åˆ«å
      for (final alias in entry.value.aliases) {
        if (merchantName.contains(alias) || alias.contains(merchantName)) {
          return CategoryMatch(entry.value.category, entry.value.confidence * 0.8);
        }
      }
    }

    return null;
  }
}

class MerchantInfo {
  final String category;
  final LedgerType ledgerType;
  final double confidence;
  final List<String> aliases;

  const MerchantInfo({
    required this.category,
    required this.ledgerType,
    required this.confidence,
    this.aliases = const [],
  });
}
```

---

### 2.3 ç”¨æˆ·ç¡®è®¤ç•Œé¢

**UIè®¾è®¡:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â† OCRè¯†åˆ«ç»“æœ              ç¡®è®¤ä¿å­˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [ç…§ç‰‡é¢„è§ˆ]                  â”‚   â”‚
â”‚  â”‚                             â”‚   â”‚
â”‚  â”‚   [æ”¶æ®ç…§ç‰‡ç¼©ç•¥å›¾]          â”‚   â”‚
â”‚  â”‚                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚
â”‚  è¯†åˆ«ç»“æœï¼š                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ é‡‘é¢ï¼šÂ¥ 1,280          âœ“   â”‚    â”‚  â† å¯ç¼–è¾‘
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ æ—¥æœŸï¼š2026/2/3         âœ“   â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ å•†å®¶ï¼šå‰é‡å®¶           âœ“   â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ åˆ†ç±»ï¼šé£Ÿè²»ï¼ˆå¤–é£Ÿï¼‰     â–¼   â”‚    â”‚  â† è‡ªåŠ¨æ¨è
â”‚  â”‚ è´¦æˆ·ï¼šğŸ’– çµé­‚          â–¼   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚
â”‚  ç½®ä¿¡åº¦ï¼š85%                        â”‚  â† æ˜¾ç¤ºè¯†åˆ«å¯ä¿¡åº¦
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚                                     â”‚
â”‚  âš ï¸ è¯·ç¡®è®¤è¯†åˆ«ç»“æœæ˜¯å¦æ­£ç¡®          â”‚
â”‚                                     â”‚
â”‚  [é‡æ–°æ‰«æ]            [ç¡®è®¤ä¿å­˜]    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å®ç°ä»£ç :**

```dart
// lib/features/ocr/presentation/ocr_confirmation_screen.dart

class OCRConfirmationScreen extends ConsumerStatefulWidget {
  final ReceiptData receiptData;

  const OCRConfirmationScreen({required this.receiptData});

  @override
  ConsumerState<OCRConfirmationScreen> createState() => _OCRConfirmationScreenState();
}

class _OCRConfirmationScreenState extends ConsumerState<OCRConfirmationScreen> {
  late int? _amount;
  late DateTime? _date;
  late String? _merchant;
  late String? _categoryId;
  late LedgerType? _ledgerType;

  @override
  void initState() {
    super.initState();
    _amount = widget.receiptData.amount;
    _date = widget.receiptData.date;
    _merchant = widget.receiptData.merchant;
    _categoryId = widget.receiptData.category?.categoryId;
    _ledgerType = widget.receiptData.category?.ledgerType;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('OCRè­˜åˆ¥çµæœ'),
        actions: [
          TextButton(
            onPressed: _onConfirm,
            child: Text('ç¢ºèªä¿å­˜'),
          ),
        ],
      ),
      body: ListView(
        padding: EdgeInsets.all(16),
        children: [
          _buildPhotoPreview(),
          SizedBox(height: 24),
          Text('è­˜åˆ¥çµæœ:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
          SizedBox(height: 12),
          _buildAmountField(),
          SizedBox(height: 12),
          _buildDateField(),
          SizedBox(height: 12),
          _buildMerchantField(),
          SizedBox(height: 12),
          _buildCategoryField(),
          SizedBox(height: 12),
          _buildLedgerTypeField(),
          SizedBox(height: 24),
          _buildConfidenceBadge(),
          SizedBox(height: 24),
          _buildWarning(),
          SizedBox(height: 24),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: _onRescan,
                  child: Text('å†ã‚¹ã‚­ãƒ£ãƒ³'),
                ),
              ),
              SizedBox(width: 12),
              Expanded(
                child: ElevatedButton(
                  onPressed: _onConfirm,
                  child: Text('ç¢ºèªä¿å­˜'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildPhotoPreview() {
    return Container(
      height: 200,
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey[300]!),
        borderRadius: BorderRadius.circular(12),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(12),
        child: FutureBuilder<Uint8List>(
          future: _loadDecryptedPhoto(),
          builder: (context, snapshot) {
            if (snapshot.hasData) {
              return Image.memory(snapshot.data!, fit: BoxFit.cover);
            }
            return Center(child: CircularProgressIndicator());
          },
        ),
      ),
    );
  }

  Widget _buildAmountField() {
    return _buildEditableField(
      label: 'é‡‘é¡',
      value: _amount != null ? 'Â¥${_formatAmount(_amount!)}' : '',
      icon: _amount != null ? Icons.check_circle : Icons.error,
      iconColor: _amount != null ? Colors.green : Colors.red,
      onTap: () => _editAmount(),
    );
  }

  Widget _buildConfidenceBadge() {
    final confidence = widget.receiptData.confidence;
    final percentage = (confidence * 100).toInt();

    Color badgeColor;
    if (confidence >= 0.8) {
      badgeColor = Colors.green;
    } else if (confidence >= 0.6) {
      badgeColor = Colors.orange;
    } else {
      badgeColor = Colors.red;
    }

    return Container(
      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: badgeColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: badgeColor),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.analytics, size: 16, color: badgeColor),
          SizedBox(width: 8),
          Text(
            'ç½®ä¿¡åº¦: $percentage%',
            style: TextStyle(color: badgeColor, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  Widget _buildWarning() {
    return Container(
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.orange[50],
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.orange),
      ),
      child: Row(
        children: [
          Icon(Icons.warning, color: Colors.orange),
          SizedBox(width: 12),
          Expanded(
            child: Text(
              'âš ï¸ è«‹ç¢ºèªè­˜åˆ¥çµæœæ˜¯å¦æ­£ç¢º',
              style: TextStyle(color: Colors.orange[900]),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _onConfirm() async {
    // éªŒè¯å¿…å¡«å­—æ®µ
    if (_amount == null || _amount! <= 0) {
      _showError('è«‹è¼¸å…¥æœ‰æ•ˆçš„é‡‘é¡');
      return;
    }

    if (_categoryId == null) {
      _showError('è«‹é¸æ“‡åˆ†é¡');
      return;
    }

    // åˆ›å»ºäº¤æ˜“
    final transaction = Transaction(
      id: uuid.v4(),
      bookId: await _bookRepo.getCurrentBookId(),
      deviceId: await _keyManager.getDeviceId(),
      amount: _amount!,
      type: TransactionType.expense,
      categoryId: _categoryId!,
      ledgerType: _ledgerType ?? LedgerType.survival,
      timestamp: _date ?? DateTime.now(),
      note: _merchant,
      photoHash: widget.receiptData.photoHash,
      createdAt: DateTime.now(),
    );

    // ä¿å­˜
    await ref.read(createTransactionUseCaseProvider).execute(transaction);

    // è¿”å›é¦–é¡µ
    if (!mounted) return;
    Navigator.of(context).popUntil((route) => route.isFirst);
  }

  void _onRescan() {
    Navigator.of(context).pop();
  }

  Future<Uint8List> _loadDecryptedPhoto() async {
    final encryptedBytes = await _photoRepo.getPhoto(widget.receiptData.photoHash);
    return await _encryption.decryptBytes(encryptedBytes);
  }
}
```

---

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 ç…§ç‰‡å­˜å‚¨

```dart
// lib/features/ocr/data/models/receipt_photo.dart

@DataClassName('ReceiptPhotoData')
class ReceiptPhotos extends Table {
  TextColumn get hash => text()();  // SHA-256å“ˆå¸Œï¼ˆä½œä¸ºä¸»é”®ï¼‰
  TextColumn get filePath => text()();  // åŠ å¯†æ–‡ä»¶è·¯å¾„
  IntColumn get fileSize => integer()();  // æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  IntColumn get createdAt => integer()();

  @override
  Set<Column> get primaryKey => {hash};
}
```

---

## 4. UI/UXè®¾è®¡

### 4.1 æ‰«æå…¥å£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Home Pocket            â˜°          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  [â• æ–°å¢è®°å½•]                       â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”      â”‚
â”‚                                     â”‚
â”‚  å¿«é€Ÿå½•å…¥ï¼š                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ ğŸ“· æ‰«ææ”¶æ®                 â”‚    â”‚  â† OCRå…¥å£
â”‚  â”‚ è‡ªåŠ¨è¯†åˆ«é‡‘é¢ã€æ—¥æœŸã€å•†å®¶     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ âœï¸ æ‰‹åŠ¨è¾“å…¥                 â”‚    â”‚
â”‚  â”‚ ä¼ ç»Ÿè®°è´¦æ–¹å¼                â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 5.1 ç¬¬ä¸‰æ–¹åº“ä¾èµ–

```yaml
# pubspec.yaml

dependencies:
  # OCR
  google_mlkit_text_recognition: ^0.13.0

  # å›¾åƒå¤„ç†
  image: ^4.1.7
  image_picker: ^1.0.7

  # åŠ å¯†
  cryptography: ^2.7.0
```

---

## 6. éªŒæ”¶æ ‡å‡†

### 6.1 åŠŸèƒ½å®Œæ•´æ€§

- âœ… é‡‘é¢è¯†åˆ«å‡†ç¡®ç‡>90%ï¼ˆæ¸…æ™°æ”¶æ®ï¼‰
- âœ… æ—¥æœŸè¯†åˆ«å‡†ç¡®ç‡>85%
- âœ… å•†å®¶è¯†åˆ«å‡†ç¡®ç‡>80%
- âœ… è¯†åˆ«é€Ÿåº¦<2ç§’
- âœ… æ”¯æŒæ¨¡ç³Šã€å€¾æ–œã€è¤¶çš±çš„æ”¶æ®ç…§ç‰‡
- âœ… è¯†åˆ«å¤±è´¥æ—¶æä¾›å‹å¥½é”™è¯¯æç¤º
- âœ… ç”¨æˆ·å¯æ‰‹åŠ¨ä¿®æ­£è¯†åˆ«ç»“æœ

---

## 7. æµ‹è¯•ç”¨ä¾‹

### 7.1 å•å…ƒæµ‹è¯•

```dart
void main() {
  group('ScanReceiptUseCase', () {
    test('should extract amount correctly', () async {
      // Given
      final mockText = 'å‰é‡å®¶\n2026/2/3\nåˆè¨ˆ Â¥1,280';

      // When
      final result = useCase._extractAmount(mockText);

      // Then
      expect(result, 1280);
    });

    test('should extract date correctly', () async {
      // Given
      final mockText = '2026å¹´2æœˆ3æ—¥\nÂ¥1,280';

      // When
      final result = useCase._extractDate(mockText);

      // Then
      expect(result, DateTime(2026, 2, 3));
    });
  });
}
```

---

## 8. å¼€å‘é‡Œç¨‹ç¢‘ï¼ˆ7å¤©ï¼‰

| Day | ä»»åŠ¡ | äº§å‡º |
|-----|------|------|
| **Day 1** | ML Kité›†æˆ | OCRè¯†åˆ«åŸºç¡€ |
| **Day 2** | å›¾åƒé¢„å¤„ç† | å»å™ªã€äºŒå€¼åŒ– |
| **Day 3** | æ•°æ®æå– | æ­£åˆ™åŒ¹é…ç®—æ³• |
| **Day 4** | å•†å®¶æ•°æ®åº“ | 500+å•†å®¶ |
| **Day 5** | ç…§ç‰‡åŠ å¯† | å­˜å‚¨ä¸è§£å¯† |
| **Day 6** | UIå®ç° | ç¡®è®¤é¡µé¢ |
| **Day 7** | æµ‹è¯•ä¼˜åŒ– | å‡†ç¡®ç‡æµ‹è¯• |

---

**æ–‡æ¡£çŠ¶æ€:** å®Œæˆ
**å®¡æ ¸çŠ¶æ€:** å¾…è¯„å®¡

**å˜æ›´æ—¥å¿—:**
- 2026-02-03: åˆç‰ˆå®Œæˆ
